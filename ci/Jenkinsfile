pipeline {
  agent any

  options {
    skipDefaultCheckout(true)
    timeout(time: 40, unit: 'MINUTES')
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    disableConcurrentBuilds()
    timestamps()
  }

  parameters {
    choice(
      name: 'BRANCH',
      choices: ['staging', 'main'],
      description: 'Rama a desplegar (stagingâ†’preproducciÃ³n, mainâ†’producciÃ³n)'
    )
    booleanParam(
      name: 'SKIP_TESTS',
      defaultValue: false,
      description: 'âš ï¸ Omitir pruebas frontend (no recomendado)'
    )
    string(
      name: 'SSH_HOST',
      defaultValue: 'inatrace.espam.edu.ec',
      description: 'Host o IP del servidor remoto Fortaleza (test/prod)'
    )
    string(
      name: 'SSH_USER',
      defaultValue: 'inatrace',
      description: 'Usuario SSH en el servidor remoto'
    )
    string(
      name: 'SSH_PORT',
      defaultValue: '22',
      description: 'Puerto SSH para el servidor remoto'
    )
    string(
      name: 'STAGING_TARGET_DIR',
      defaultValue: '/opt/inatrace/frontend/test/fortaleza',
      description: 'Directorio remoto para despliegue de preproducciÃ³n (Fortaleza)'
    )
    string(
      name: 'PROD_TARGET_DIR',
      defaultValue: '/opt/inatrace/frontend/prod/fortaleza',
      description: 'Directorio remoto para despliegue de producciÃ³n (Fortaleza)'
    )
    string(
      name: 'STAGING_HEALTHCHECK_URL',
      defaultValue: 'https://testinatrace.espam.edu.ec/health',
      description: 'URL externa para validar healthcheck en preproducciÃ³n'
    )
    string(
      name: 'PROD_HEALTHCHECK_URL',
      defaultValue: 'https://inatrace.espam.edu.ec/health',
      description: 'URL externa para validar healthcheck en producciÃ³n'
    )
  }

  environment {
    REGISTRY = 'ghcr.io'
    NODE_VERSION = '14'
    DOCKER_BUILDKIT = '1'
    COMPOSE_DOCKER_CLI_BUILD = '1'
    COMPOSE_DIR = 'ci'
    DEPLOY_NETWORK_FRONT = 'inatrace-frontend-fortaleza-network'
    DEPLOY_NETWORK_BACK = 'inatrace-backend-fortaleza-network'
    HEALTH_MAX_RETRIES = '12'
    HEALTH_SLEEP = '10'
  }

  stages {
    stage('ğŸ” Preflight credenciales') {
      steps {
        script {
          def missing = []
          def gitAuthMode = ''
          def gitAuthUser = ''

          try {
            withCredentials([usernamePassword(credentialsId: 'github-pat', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')]) {
              gitAuthMode = 'usernamePassword'
              gitAuthUser = GIT_USER
            }
          } catch (Exception primaryError) {
            try {
              withCredentials([string(credentialsId: 'github-pat', variable: 'GIT_TOKEN')]) {
                gitAuthMode = 'tokenOnly'
                gitAuthUser = 'oauth2'
              }
            } catch (Exception secondaryError) {
              missing << 'github-pat'
              echo "âš ï¸ No se pudo cargar 'github-pat' como username/password (${primaryError.class.simpleName}) ni como secret text (${secondaryError.class.simpleName})."
            }
          }

          try {
            withCredentials([usernamePassword(credentialsId: 'ghcr-credentials', usernameVariable: 'DUMMY_USER', passwordVariable: 'DUMMY_TOKEN')]) {
              // Credencial vÃ¡lida
            }
          } catch (Exception ghcrError) {
            missing << 'ghcr-credentials'
            echo "âš ï¸ Credencial 'ghcr-credentials' invÃ¡lida: ${ghcrError.class.simpleName}"
          }

          try {
            withCredentials([
              sshUserPrivateKey(
                credentialsId: 'usuario-prod-ssh',
                keyFileVariable: 'SSH_KEY_FILE',
                usernameVariable: 'SSH_USERNAME',
                passphraseVariable: 'SSH_PASSPHRASE'
              )
            ]) {
              sh(label: 'Validar usuario-prod-ssh', script: '''
                set -e
                if [ ! -f "$SSH_KEY_FILE" ]; then
                  echo "âŒ Clave SSH no disponible"
                  exit 1
                fi
              ''')
            }
          } catch (Exception sshError) {
            missing << 'usuario-prod-ssh'
            echo "âš ï¸ Credencial 'usuario-prod-ssh' invÃ¡lida: ${sshError.class.simpleName}"
          }

          if (!gitAuthMode) {
            missing << 'github-pat'
          }

          if (missing) {
            error("âŒ Credenciales faltantes o invÃ¡lidas: ${missing.unique().join(', ')}")
          }

          env.GIT_AUTH_MODE = gitAuthMode
          env.GIT_AUTH_USER = gitAuthUser ?: 'oauth2'
          echo "âœ… Credenciales verificadas. Modo Git: ${gitAuthMode}"
        }
      }
    }

    stage('ğŸ“¥ Checkout') {
      steps {
        cleanWs()
        script {
          def repoUrl = 'https://github.com/Atijaguar-ec/fe.git'
          def branchRef = params.BRANCH ?: 'staging'

          if (env.GIT_AUTH_MODE == 'usernamePassword') {
            checkout([
              $class: 'GitSCM',
              branches: [[name: "*/${branchRef}" ]],
              userRemoteConfigs: [[
                url: repoUrl,
                credentialsId: 'github-pat'
              ]],
              extensions: [
                [$class: 'CloneOption', shallow: false, depth: 0, noTags: false]
              ]
            ])
          } else {
            withCredentials([string(credentialsId: 'github-pat', variable: 'GIT_TOKEN')]) {
              sh(label: 'Manual git clone con PAT', script: """
set -eu

git clone --origin origin --branch ${branchRef} https://${env.GIT_AUTH_USER}:\${GIT_TOKEN}@github.com/Atijaguar-ec/fe.git .
git remote set-url origin ${repoUrl}
git fetch --tags --prune origin
              """)
            }
          }
        }
      }
    }

    stage('ğŸ”§ InicializaciÃ³n') {
      steps {
        script {
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  INICIO DE DESPLIEGUE FRONTEND - FORTALEZA DEL VALLE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Rama: ${params.BRANCH}"
          echo "Usuario: ${env.BUILD_USER ?: 'Sistema'}"
          echo "Timestamp: ${new Date().format('yyyy-MM-dd HH:mm:ss z')}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        }

        script {
          def remoteUrl = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()
          remoteUrl = remoteUrl.replaceAll(/\.git$/, '')
          remoteUrl = remoteUrl.replaceFirst(/^https?:\/\/github.com\//, '')
          remoteUrl = remoteUrl.replaceFirst(/^git@github.com:/, '')

          env.REPO_FULL_NAME = remoteUrl
          env.GIT_SHORT_SHA = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          env.GIT_COMMIT_MSG = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
          env.GIT_AUTHOR = sh(script: 'git log -1 --pretty=%an', returnStdout: true).trim()

          env.IMAGE_REPOSITORY = (env.REGISTRY + '/' + (env.REPO_FULL_NAME + '-inatrace')).toLowerCase()
          env.DEPLOY_TAG = params.BRANCH == 'main' ? 'latest' : "test-${env.GIT_SHORT_SHA}"
          env.FORTALEZA_ENV = params.BRANCH == 'main' ? 'prod' : 'test'
          env.HEALTHCHECK_URL = params.BRANCH == 'main' ? params.PROD_HEALTHCHECK_URL : params.STAGING_HEALTHCHECK_URL

          echo "\nğŸ“¦ InformaciÃ³n del Build :"
          echo "  - Repositorio: ${env.REPO_FULL_NAME}"
          echo "  - Commit: ${env.GIT_SHORT_SHA}"
          echo "  - Autor: ${env.GIT_AUTHOR}"
          echo "  - Mensaje: ${env.GIT_COMMIT_MSG}"
          echo "  - Imagen: ${env.IMAGE_REPOSITORY}:${env.DEPLOY_TAG}"
          echo "  - Entorno destino: ${env.FORTALEZA_ENV}"
        }
      }
    }

    stage('ğŸ§ª Tests & Quality') {
      when {
        expression { return !params.SKIP_TESTS }
      }
      steps {
        script {
          echo "\nğŸ§ª Ejecutando lint y pruebas unitarias..."
          sh """
            set -e
            docker run --rm \
              -e CHROME_BIN=/usr/bin/chromium-browser \
              -e PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 \
              -v "${env.WORKSPACE}":/workspace \
              -w /workspace \
              node:${NODE_VERSION}-alpine sh -c '
                set -e
                apk add --no-cache git chromium nss openssh
                npm config set cache /tmp/npm-cache --global
                npm ci
                npm run lint
                npm run test -- --watch=false --progress=false --browsers=ChromeHeadlessCI
              '
          """
        }
      }
    }

    stage('ğŸ—ï¸ Build & Push Imagen') {
      steps {
        script {
          echo "\nğŸ—ï¸ Construyendo y publicando imagen Docker..."
        }

        withCredentials([
          usernamePassword(credentialsId: 'ghcr-credentials', usernameVariable: 'GHCR_USER', passwordVariable: 'GHCR_TOKEN')
        ]) {
          script {
            def imageTag = "${env.IMAGE_REPOSITORY}:${env.DEPLOY_TAG}"
            def latestTag = "${env.IMAGE_REPOSITORY}:latest"
            sh """
              set -e
              echo "ğŸ” Autenticando en GHCR..."
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin

              BUILD_DATE=\$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              docker build \
                --build-arg BUILD_DATE=\$BUILD_DATE \
                --build-arg VCS_REF=${env.GIT_SHORT_SHA} \
                --build-arg VERSION=${env.DEPLOY_TAG} \
                --label org.opencontainers.image.created=\$BUILD_DATE \
                --label org.opencontainers.image.revision=${env.GIT_SHORT_SHA} \
                --label org.opencontainers.image.version=${env.DEPLOY_TAG} \
                --label org.opencontainers.image.source=https://github.com/${env.REPO_FULL_NAME} \
                -t ${imageTag} .

              if [ "${params.BRANCH}" = "main" ]; then
                docker tag ${imageTag} ${latestTag}
              fi

              docker push ${imageTag}

              if [ "${params.BRANCH}" = "main" ]; then
                docker push ${latestTag}
              fi
            """
          }
        }
      }
    }

    stage('ğŸš€ Deploy Fortaleza') {
      steps {
        script {
          def deploy = [:]
          if (params.BRANCH == 'main') {
            deploy = [
              name: 'Fortaleza ProducciÃ³n',
              nodeEnv: 'production',
              targetDir: params.PROD_TARGET_DIR,
              containerName: 'inatrace-fe-prod-fortaleza',
              hostPort: '8081',
              traefikRouter: 'inatrace-fe-prod-fortaleza',
              traefikRule: 'Host(`inatrace.espam.edu.ec`)',
              traefikEntrypoints: 'websecure',
              traefikResolver: 'letsencrypt',
              healthLocal: 'http://localhost:8081/health',
              healthExternal: params.PROD_HEALTHCHECK_URL
            ]
          } else {
            deploy = [
              name: 'Fortaleza PreproducciÃ³n',
              nodeEnv: 'test',
              targetDir: params.STAGING_TARGET_DIR,
              containerName: 'inatrace-fe-test-fortaleza',
              hostPort: '8081',
              traefikRouter: 'inatrace-fe-test-fortaleza',
              traefikRule: 'Host(`testinatrace.espam.edu.ec`)',
              traefikEntrypoints: 'websecure',
              traefikResolver: 'letsencrypt',
              healthLocal: 'http://localhost:8081/health',
              healthExternal: params.STAGING_HEALTHCHECK_URL
            ]
          }

          deploy.frontendNetwork = env.DEPLOY_NETWORK_FRONT
          deploy.backendNetwork = env.DEPLOY_NETWORK_BACK

          env.CURRENT_DEPLOY_NAME = deploy.name
          env.CURRENT_DEPLOY_DIR = deploy.targetDir
          env.CURRENT_HEALTH_URL = deploy.healthExternal

          echo "\nğŸš€ Iniciando despliegue remoto: ${deploy.name}"

          def envContent = """
# Frontend-specific variables (not backend)
FE_IMAGE_NAME=${env.IMAGE_REPOSITORY}
FE_TAG=${env.DEPLOY_TAG}
CONTAINER_NAME=${deploy.containerName}
HOST_HTTP_PORT=${deploy.hostPort}
FRONTEND_NETWORK=${deploy.frontendNetwork}
BACKEND_NETWORK=${deploy.backendNetwork}
TRAEFIK_ENABLE=true
TRAEFIK_ROUTER_NAME=${deploy.traefikRouter}
TRAEFIK_ROUTER_RULE=${deploy.traefikRule}
TRAEFIK_ENTRYPOINTS=${deploy.traefikEntrypoints}
TRAEFIK_CERT_RESOLVER=${deploy.traefikResolver}
HEALTHCHECK_URL=http://localhost
HEALTHCHECK_INTERVAL=15s
HEALTHCHECK_TIMEOUT=5s
HEALTHCHECK_RETRIES=3
HEALTHCHECK_START_PERIOD=10s
NGINX_CONF_PATH=./nginx.conf
""".stripIndent().trim() + '\n'
          writeFile file: "${env.WORKSPACE}/ci/.env.deploy", text: envContent

          def remoteScript = """#!/bin/bash
set -euo pipefail

REMOTE_DIR="\${deploy.targetDir}"
FRONTEND_NETWORK="\${deploy.frontendNetwork}"
BACKEND_NETWORK="\${deploy.backendNetwork}"
HEALTH_URL="http://localhost"
MAX_RETRIES=\${env.HEALTH_MAX_RETRIES}
SLEEP_TIME=\${env.HEALTH_SLEEP}

if command -v docker compose >/dev/null 2>&1; then
  COMPOSE_CMD="docker compose"
elif command -v docker-compose >/dev/null 2>&1; then
  COMPOSE_CMD="docker-compose"
else
  echo "âŒ Docker Compose no estÃ¡ instalado" >&2
  exit 1
fi

cd "\$REMOTE_DIR"

docker network inspect "\$FRONTEND_NETWORK" >/dev/null 2>&1 || docker network create "\$FRONTEND_NETWORK"
docker network inspect "\$BACKEND_NETWORK" >/dev/null 2>&1 || docker network create "\$BACKEND_NETWORK"

\$COMPOSE_CMD pull
\$COMPOSE_CMD up -d --force-recreate

echo "â³ Esperando healthcheck (\$HEALTH_URL)..."
retry=0
while [ "\$retry" -lt "\$MAX_RETRIES" ]; do
  retry=\$((retry + 1))
  if curl -fsS --max-time 5 "\$HEALTH_URL" >/dev/null 2>&1; then
    echo "âœ… Frontend saludable en intento \$retry"
    \$COMPOSE_CMD ps
    exit 0
  fi
  echo "â³ Intento \$retry/\$MAX_RETRIES - Esperando \$SLEEP_TIME s..."
  sleep "\$SLEEP_TIME"
done

echo "âŒ Healthcheck fallÃ³ tras \$MAX_RETRIES intentos" >&2
\$COMPOSE_CMD logs --tail=100
exit 1
"""
          writeFile file: "${env.WORKSPACE}/ci/remote-deploy.sh", text: remoteScript

          if (params.BRANCH == 'main') {
            withCredentials([
              sshUserPrivateKey(
                credentialsId: 'usuario-prod-ssh',
                keyFileVariable: 'SSH_KEY_FILE',
                usernameVariable: 'SSH_USERNAME',
                passphraseVariable: 'SSH_PASSPHRASE'
              )
            ]) {
              sh """
                set -e
                SSH_TARGET="${params.SSH_USER}@${params.SSH_HOST}"
                SSH_PORT="${params.SSH_PORT}"
                REMOTE_DIR="${deploy.targetDir}"
                SSH_KEY_PATH="\$SSH_KEY_FILE"

                chmod 600 "\$SSH_KEY_PATH" || true

                echo "ğŸ“ Creando directorio remoto si no existe..."
                ssh -i "\$SSH_KEY_PATH" -p "\$SSH_PORT" -o StrictHostKeyChecking=no "\$SSH_TARGET" "mkdir -p \$REMOTE_DIR"

                echo "ğŸ“¤ Copiando docker-compose.yml"
                scp -i "\$SSH_KEY_PATH" -P "\$SSH_PORT" -o StrictHostKeyChecking=no "${env.WORKSPACE}/ci/docker-compose.yml" "\$SSH_TARGET:\$REMOTE_DIR/docker-compose.yml"

                echo "ğŸ“¤ Copiando nginx.conf"
                scp -i "\$SSH_KEY_PATH" -P "\$SSH_PORT" -o StrictHostKeyChecking=no "${env.WORKSPACE}/nginx.conf" "\$SSH_TARGET:\$REMOTE_DIR/nginx.conf"

                echo "ğŸ“¤ Copiando archivo .env"
                scp -i "\$SSH_KEY_PATH" -P "\$SSH_PORT" -o StrictHostKeyChecking=no "${env.WORKSPACE}/ci/.env.deploy" "\$SSH_TARGET:\$REMOTE_DIR/.env"

                echo "ğŸ“¤ Copiando script de despliegue"
                scp -i "\$SSH_KEY_PATH" -P "\$SSH_PORT" -o StrictHostKeyChecking=no "${env.WORKSPACE}/ci/remote-deploy.sh" "\$SSH_TARGET:\$REMOTE_DIR/remote-deploy.sh"

                echo "ğŸš€ Ejecutando despliegue en servidor remoto..."
                ssh -i "\$SSH_KEY_PATH" -p "\$SSH_PORT" -o StrictHostKeyChecking=no "\$SSH_TARGET" "chmod +x \$REMOTE_DIR/remote-deploy.sh && \$REMOTE_DIR/remote-deploy.sh"
              """
            }
          } else if (params.BRANCH == 'staging') {
            withCredentials([
              file(credentialsId: 'fortaleza-frontend-env-staging', variable: 'ENVFILE')
            ]) {
              sh """
                set -e

                echo "ğŸ”— Verificando red Docker local..."
                docker network inspect inatrace-frontend-network >/dev/null 2>&1 || \
                  docker network create inatrace-frontend-network
                docker network inspect inatrace-backend-network >/dev/null 2>&1 || \
                  docker network create inatrace-backend-network

                echo "ğŸ“ Preparando archivo .env para docker compose..."
                cp "${env.WORKSPACE}/ci/.env.frontend" ci/.env
                
                # Actualizar variables especÃ­ficas para este build
                sed -i "s|FE_TAG=.*|FE_TAG=${env.DEPLOY_TAG}|g" ci/.env
                sed -i "s|CONTAINER_NAME=.*|CONTAINER_NAME=${deploy.containerName}|g" ci/.env

                # Forzar configuraciÃ³n de entorno y producto para staging
                if grep -q '^NODE_ENV=' ci/.env; then
                  sed -i "s|^NODE_ENV=.*|NODE_ENV=test|g" ci/.env
                else
                  echo "NODE_ENV=test" >> ci/.env
                fi

                if grep -q '^PRIMARY_PRODUCT_TYPE=' ci/.env; then
                  sed -i "s|^PRIMARY_PRODUCT_TYPE=.*|PRIMARY_PRODUCT_TYPE=COCOA|g" ci/.env
                else
                  echo "PRIMARY_PRODUCT_TYPE=COCOA" >> ci/.env
                fi

                echo "ğŸ§¾ Copiando nginx.conf para despliegue local..."
                cp "${env.WORKSPACE}/nginx.conf" ci/nginx.conf

                echo "ğŸ“¥ Descargando Ãºltima imagen..."
                docker compose -f ci/docker-compose.yml pull || true

                echo "ğŸ”„ Desplegando servicios localmente..."
                docker compose -f ci/docker-compose.yml up -d --remove-orphans --force-recreate

                echo "ğŸ“Š Estado inicial de contenedores:"
                docker compose -f ci/docker-compose.yml ps

                echo "â³ Esperando healthcheck local..."
                RETRY_COUNT=0
                MAX_RETRIES=${env.HEALTH_MAX_RETRIES}
                SLEEP_TIME=${env.HEALTH_SLEEP}
                HEALTH_URL="http://localhost:${deploy.hostPort}"

                while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
                  RETRY_COUNT=\$((RETRY_COUNT + 1))
                  if curl -fsS --max-time 5 "\$HEALTH_URL" >/dev/null 2>&1; then
                    echo "âœ… Frontend local saludable en intento \$RETRY_COUNT"
                    docker compose -f ci/docker-compose.yml ps
                    exit 0
                  fi
                  echo "â³ Intento \$RETRY_COUNT/\$MAX_RETRIES - Esperando \$SLEEP_TIME s..."
                  sleep "\$SLEEP_TIME"
                done

                echo "âŒ Healthcheck local fallÃ³ tras \$MAX_RETRIES intentos" >&2
                docker compose -f ci/docker-compose.yml logs --tail=100
                exit 1
              """
            }
          } else {
            echo "âš ï¸ Rama ${params.BRANCH} sin despliegue configurado (solo 'main' y 'staging')."
          }

          sh 'rm -f ci/.env.deploy ci/.env ci/nginx.conf ci/remote-deploy.sh'
        }
      }
    }
  }

  post {
    always {
      script {
        echo "\nğŸ§¹ Limpieza post-pipeline frontend..."
        sh '''
          docker logout ghcr.io || true
          docker image prune -f --filter "dangling=true" || true
        '''
      }
    }
    success {
      script {
        def successMessage = params.BRANCH == 'main' ?
          'âœ… FRONTEND FORTALEZA DESPLEGADO - PRODUCCIÃ“N' :
          'âœ… FRONTEND FORTALEZA DESPLEGADO - PREPRODUCCIÃ“N'
        echo "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  ${successMessage}"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Imagen: ${env.IMAGE_REPOSITORY}:${env.DEPLOY_TAG}"
        echo "Commit: ${env.GIT_SHORT_SHA}"
        echo "Servidor: ${params.SSH_HOST}"
        echo "Directorio: ${env.CURRENT_DEPLOY_DIR ?: 'N/D'}"
        echo "Healthcheck externo: ${env.HEALTHCHECK_URL}"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      }
    }
    failure {
      script {
        def failureMessage = params.BRANCH == 'main' ?
          'âŒ FALLÃ“ DESPLIEGUE FRONTEND PRODUCCIÃ“N' :
          'âŒ FALLÃ“ DESPLIEGUE FRONTEND PREPRODUCCIÃ“N'
        echo "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  ${failureMessage}"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Revisa los logs arriba para mÃ¡s detalles"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      }
    }
  }
}
