/*
 * Copyright(c) 2009 - 2019 Abelium d.o.o.
 * Kajuhova 90, 1000 Ljubljana, Slovenia
 * All rights reserved
 * Copyright(c) 1995 - 2018 T-Systems Multimedia Solutions GmbH
 * Riesaer Str. 5, 01129 Dresden
 * All rights reserved.
 *
 * coffee-be
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the openapi-typescript-angular-generator.
 * https://github.com/alenabelium/openapi-typescript-angular-generator
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { ValidatorFn, Validators } from '@angular/forms';

import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import { catchError }                                        from 'rxjs/operators';

import { ApiResponseAny } from '../model/apiResponseAny';
import { ApiResponseChainSemiProductAvailability } from '../model/apiResponseChainSemiProductAvailability';
import { ApiResponseChainSemiProductAvailabilityArray } from '../model/apiResponseChainSemiProductAvailabilityArray';
import { ApiResponseChainStockOrder } from '../model/apiResponseChainStockOrder';
import { ApiResponsePaginatedListChainStockOrder } from '../model/apiResponsePaginatedListChainStockOrder';
import { ApiResponseProcessingOrderHistoryArray } from '../model/apiResponseProcessingOrderHistoryArray';
import { AvailabilityInFacilitiesRequest } from '../model/availabilityInFacilitiesRequest';
import { ChainStockOrder } from '../model/chainStockOrder';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/**
 * Namespace for availableQuantityOfSemiProductInFacilities.
 */
export namespace AvailableQuantityOfSemiProductInFacilities {
    /**
     * Parameter map for availableQuantityOfSemiProductInFacilities.
     */
    export interface PartialParamMap {
      AvailabilityInFacilitiesRequest: AvailabilityInFacilitiesRequest;
    }

    /**
     * Enumeration of all parameters for availableQuantityOfSemiProductInFacilities.
     */
    export enum Parameters {
      AvailabilityInFacilitiesRequest = 'AvailabilityInFacilitiesRequest'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of availableQuantityOfSemiProductInFacilities
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof AvailableQuantityOfSemiProductInFacilities.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for availableQuantityOfSemiProductInFacility.
 */
export namespace AvailableQuantityOfSemiProductInFacility {
    /**
     * Parameter map for availableQuantityOfSemiProductInFacility.
     */
    export interface PartialParamMap {
      facilityId: string;
      semiProductId: string;
    }

    /**
     * Enumeration of all parameters for availableQuantityOfSemiProductInFacility.
     */
    export enum Parameters {
      facilityId = 'facilityId',
      semiProductId = 'semiProductId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of availableQuantityOfSemiProductInFacility
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof AvailableQuantityOfSemiProductInFacility.PartialParamMap]?: [string, ValidatorFn][]} = {
      facilityId: [
              ['required', Validators.required],
      ],
      semiProductId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteStockOrder.
 */
export namespace DeleteStockOrder {
    /**
     * Parameter map for deleteStockOrder.
     */
    export interface PartialParamMap {
      ChainStockOrder: ChainStockOrder;
    }

    /**
     * Enumeration of all parameters for deleteStockOrder.
     */
    export enum Parameters {
      ChainStockOrder = 'ChainStockOrder'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteStockOrder
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteStockOrder.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteStockOrders.
 */
export namespace DeleteStockOrders {
    /**
     * Parameter map for deleteStockOrders.
     */
    export interface PartialParamMap {
      ChainStockOrder: Array<ChainStockOrder>;
    }

    /**
     * Enumeration of all parameters for deleteStockOrders.
     */
    export enum Parameters {
      ChainStockOrder = 'ChainStockOrder'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteStockOrders
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteStockOrders.PartialParamMap]?: [string, ValidatorFn][]} = {
      ChainStockOrder: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getAggregatesForStockOrder.
 */
export namespace GetAggregatesForStockOrder {
    /**
     * Parameter map for getAggregatesForStockOrder.
     */
    export interface PartialParamMap {
      /**
       * stock order dbID
       */
      stockOrderId: string;
    }

    /**
     * Enumeration of all parameters for getAggregatesForStockOrder.
     */
    export enum Parameters {
      /**
       * stock order dbID
       */
      stockOrderId = 'stockOrderId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getAggregatesForStockOrder
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetAggregatesForStockOrder.PartialParamMap]?: [string, ValidatorFn][]} = {
      stockOrderId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getB2CDataForStockOrder.
 */
export namespace GetB2CDataForStockOrder {
    /**
     * Parameter map for getB2CDataForStockOrder.
     */
    export interface PartialParamMap {
      /**
       * stock order dbID
       */
      stockOrderId: string;
      orderId?: boolean;
      cooperative?: boolean;
      cuppingGrade?: boolean;
    }

    /**
     * Enumeration of all parameters for getB2CDataForStockOrder.
     */
    export enum Parameters {
      /**
       * stock order dbID
       */
      stockOrderId = 'stockOrderId',
      orderId = 'orderId',
      cooperative = 'cooperative',
      cuppingGrade = 'cuppingGrade'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getB2CDataForStockOrder
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetB2CDataForStockOrder.PartialParamMap]?: [string, ValidatorFn][]} = {
      stockOrderId: [
              ['required', Validators.required],
      ],
      orderId: [
      ],
      cooperative: [
      ],
      cuppingGrade: [
      ],
    };
}

/**
 * Namespace for getSeasonalStatisticsForOrganization.
 */
export namespace GetSeasonalStatisticsForOrganization {
    /**
     * Parameter map for getSeasonalStatisticsForOrganization.
     */
    export interface PartialParamMap {
      /**
       * stock order dbID
       */
      organizationId: string;
      fromDate: string;
      toDate: string;
      specificOrder?: string;
    }

    /**
     * Enumeration of all parameters for getSeasonalStatisticsForOrganization.
     */
    export enum Parameters {
      /**
       * stock order dbID
       */
      organizationId = 'organizationId',
      fromDate = 'fromDate',
      toDate = 'toDate',
      specificOrder = 'specificOrder'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getSeasonalStatisticsForOrganization
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetSeasonalStatisticsForOrganization.PartialParamMap]?: [string, ValidatorFn][]} = {
      organizationId: [
              ['required', Validators.required],
      ],
      fromDate: [
              ['required', Validators.required],
      ],
      toDate: [
              ['required', Validators.required],
      ],
      specificOrder: [
      ],
    };
}

/**
 * Namespace for getStockOrderById.
 */
export namespace GetStockOrderById {
    /**
     * Parameter map for getStockOrderById.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getStockOrderById.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getStockOrderById
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetStockOrderById.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getStockOrderByIdWithInputOrders.
 */
export namespace GetStockOrderByIdWithInputOrders {
    /**
     * Parameter map for getStockOrderByIdWithInputOrders.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getStockOrderByIdWithInputOrders.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getStockOrderByIdWithInputOrders
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetStockOrderByIdWithInputOrders.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for listAvailableStockForFacility.
 */
export namespace ListAvailableStockForFacility {
    /**
     * Parameter map for listAvailableStockForFacility.
     */
    export interface PartialParamMap {
      /**
       * _id of a given facility
       */
      facilityId: string;
      /**
       * sort order ASC or DESC
       */
      sort?: any;
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for listAvailableStockForFacility.
     */
    export enum Parameters {
      /**
       * _id of a given facility
       */
      facilityId = 'facilityId',
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listAvailableStockForFacility
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListAvailableStockForFacility.PartialParamMap]?: [string, ValidatorFn][]} = {
      facilityId: [
              ['required', Validators.required],
      ],
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for listAvailableStockForSemiProductInFacility.
 */
export namespace ListAvailableStockForSemiProductInFacility {
    /**
     * Parameter map for listAvailableStockForSemiProductInFacility.
     */
    export interface PartialParamMap {
      /**
       * _id of a given facility
       */
      facilityId: string;
      /**
       * _id of a desired semi-product
       */
      semiProductId: string;
      womensCoffee?: boolean;
      productionDateStart?: string;
      productionDateEnd?: string;
      /**
       * sort order ASC or DESC
       */
      sort?: any;
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for listAvailableStockForSemiProductInFacility.
     */
    export enum Parameters {
      /**
       * _id of a given facility
       */
      facilityId = 'facilityId',
      /**
       * _id of a desired semi-product
       */
      semiProductId = 'semiProductId',
      womensCoffee = 'womensCoffee',
      productionDateStart = 'productionDateStart',
      productionDateEnd = 'productionDateEnd',
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listAvailableStockForSemiProductInFacility
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListAvailableStockForSemiProductInFacility.PartialParamMap]?: [string, ValidatorFn][]} = {
      facilityId: [
              ['required', Validators.required],
      ],
      semiProductId: [
              ['required', Validators.required],
      ],
      womensCoffee: [
      ],
      productionDateStart: [
      ],
      productionDateEnd: [
      ],
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for listPurchaseOrderForUserCustomer.
 */
export namespace ListPurchaseOrderForUserCustomer {
    /**
     * Parameter map for listPurchaseOrderForUserCustomer.
     */
    export interface PartialParamMap {
      /**
       * userCustomerId
       */
      farmerId: string;
      showOpenBalanceOnly?: boolean;
      /**
       * sort order ASC or DESC
       */
      sort?: any;
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for listPurchaseOrderForUserCustomer.
     */
    export enum Parameters {
      /**
       * userCustomerId
       */
      farmerId = 'farmerId',
      showOpenBalanceOnly = 'showOpenBalanceOnly',
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listPurchaseOrderForUserCustomer
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListPurchaseOrderForUserCustomer.PartialParamMap]?: [string, ValidatorFn][]} = {
      farmerId: [
              ['required', Validators.required],
      ],
      showOpenBalanceOnly: [
      ],
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for listQuoteOrders.
 */
export namespace ListQuoteOrders {
    /**
     * Parameter map for listQuoteOrders.
     */
    export interface PartialParamMap {
      facilityOrOrganizationId: string;
      openOnly: boolean;
      semiProductId?: string;
      mode?: any;
      sort?: any;
      sortBy?: string;
      limit?: number;
      offset?: number;
      productionDateStart?: string;
      productionDateEnd?: string;
    }

    /**
     * Enumeration of all parameters for listQuoteOrders.
     */
    export enum Parameters {
      facilityOrOrganizationId = 'facilityOrOrganizationId',
      openOnly = 'openOnly',
      semiProductId = 'semiProductId',
      mode = 'mode',
      sort = 'sort',
      sortBy = 'sortBy',
      limit = 'limit',
      offset = 'offset',
      productionDateStart = 'productionDateStart',
      productionDateEnd = 'productionDateEnd'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listQuoteOrders
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListQuoteOrders.PartialParamMap]?: [string, ValidatorFn][]} = {
      facilityOrOrganizationId: [
              ['required', Validators.required],
      ],
      openOnly: [
              ['required', Validators.required],
      ],
      semiProductId: [
      ],
      mode: [
      ],
      sort: [
      ],
      sortBy: [
      ],
      limit: [
      ],
      offset: [
      ],
      productionDateStart: [
      ],
      productionDateEnd: [
      ],
    };
}

/**
 * Namespace for listStockForFacility.
 */
export namespace ListStockForFacility {
    /**
     * Parameter map for listStockForFacility.
     */
    export interface PartialParamMap {
      /**
       * _id of a given facility
       */
      facilityId: string;
      /**
       * show purhcase orders with open balance
       */
      showPurchaseOrderOpenBalanceOnly?: boolean;
      /**
       * show only purchase orders
       */
      purchaseOrderOnly?: boolean;
      availableOnly?: boolean;
      semiProductId?: string;
      /**
       * CASH_VIA_COOPERATIVE or CASH_VIA_COLLECTOR or BANK_TRANSFER or UNKNOWN
       */
      wayOfPayment?: any;
      /**
       * sort order ASC or DESC
       */
      sort?: any;
      sortBy?: string;
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
      womensCoffee?: boolean;
      productionDateStart?: string;
      productionDateEnd?: string;
      /**
       * by farmer name or surname
       */
      query?: string;
    }

    /**
     * Enumeration of all parameters for listStockForFacility.
     */
    export enum Parameters {
      /**
       * _id of a given facility
       */
      facilityId = 'facilityId',
      /**
       * show purhcase orders with open balance
       */
      showPurchaseOrderOpenBalanceOnly = 'showPurchaseOrderOpenBalanceOnly',
      /**
       * show only purchase orders
       */
      purchaseOrderOnly = 'purchaseOrderOnly',
      availableOnly = 'availableOnly',
      semiProductId = 'semiProductId',
      /**
       * CASH_VIA_COOPERATIVE or CASH_VIA_COLLECTOR or BANK_TRANSFER or UNKNOWN
       */
      wayOfPayment = 'wayOfPayment',
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      sortBy = 'sortBy',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset',
      womensCoffee = 'womensCoffee',
      productionDateStart = 'productionDateStart',
      productionDateEnd = 'productionDateEnd',
      /**
       * by farmer name or surname
       */
      query = 'query'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listStockForFacility
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListStockForFacility.PartialParamMap]?: [string, ValidatorFn][]} = {
      facilityId: [
              ['required', Validators.required],
      ],
      showPurchaseOrderOpenBalanceOnly: [
      ],
      purchaseOrderOnly: [
      ],
      availableOnly: [
      ],
      semiProductId: [
      ],
      wayOfPayment: [
      ],
      sort: [
      ],
      sortBy: [
      ],
      limit: [
      ],
      offset: [
      ],
      womensCoffee: [
      ],
      productionDateStart: [
      ],
      productionDateEnd: [
      ],
      query: [
      ],
    };
}

/**
 * Namespace for listStockInFacilityForCustomers.
 */
export namespace ListStockInFacilityForCustomers {
    /**
     * Parameter map for listStockInFacilityForCustomers.
     */
    export interface PartialParamMap {
      facilityOrOrganizationId: string;
      companyCustomerId?: string;
      openOnly?: boolean;
      mode?: any;
      sort?: any;
      sortBy?: string;
      limit?: number;
      offset?: number;
    }

    /**
     * Enumeration of all parameters for listStockInFacilityForCustomers.
     */
    export enum Parameters {
      facilityOrOrganizationId = 'facilityOrOrganizationId',
      companyCustomerId = 'companyCustomerId',
      openOnly = 'openOnly',
      mode = 'mode',
      sort = 'sort',
      sortBy = 'sortBy',
      limit = 'limit',
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listStockInFacilityForCustomers
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListStockInFacilityForCustomers.PartialParamMap]?: [string, ValidatorFn][]} = {
      facilityOrOrganizationId: [
              ['required', Validators.required],
      ],
      companyCustomerId: [
      ],
      openOnly: [
      ],
      mode: [
      ],
      sort: [
      ],
      sortBy: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for listStockOrders.
 */
export namespace ListStockOrders {
    /**
     * Parameter map for listStockOrders.
     */
    export interface PartialParamMap {
      /**
       * show purhcase orders with open balance
       */
      showPurchaseOrderOpenBalanceOnly?: boolean;
      /**
       * show only purchase orders
       */
      purchaseOrderOnly?: boolean;
      /**
       * sort order ASC or DESC
       */
      sort?: any;
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for listStockOrders.
     */
    export enum Parameters {
      /**
       * show purhcase orders with open balance
       */
      showPurchaseOrderOpenBalanceOnly = 'showPurchaseOrderOpenBalanceOnly',
      /**
       * show only purchase orders
       */
      purchaseOrderOnly = 'purchaseOrderOnly',
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listStockOrders
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListStockOrders.PartialParamMap]?: [string, ValidatorFn][]} = {
      showPurchaseOrderOpenBalanceOnly: [
      ],
      purchaseOrderOnly: [
      ],
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for listStockOrdersForOrganization.
 */
export namespace ListStockOrdersForOrganization {
    /**
     * Parameter map for listStockOrdersForOrganization.
     */
    export interface PartialParamMap {
      /**
       * organizationId
       */
      organizationId: string;
      /**
       * show purhcase orders with open balance
       */
      showPurchaseOrderOpenBalanceOnly?: boolean;
      /**
       * show only purchase orders
       */
      purchaseOrderOnly?: boolean;
      sort?: any;
      farmerId?: string;
      /**
       * CASH_VIA_COOPERATIVE or CASH_VIA_COLLECTOR or BANK_TRANSFER or UNKNOWN
       */
      wayOfPayment?: any;
      womensCoffee?: boolean;
      limit?: number;
      offset?: number;
      productionDateStart?: string;
      productionDateEnd?: string;
      /**
       * by farmer name or surname
       */
      query?: string;
    }

    /**
     * Enumeration of all parameters for listStockOrdersForOrganization.
     */
    export enum Parameters {
      /**
       * organizationId
       */
      organizationId = 'organizationId',
      /**
       * show purhcase orders with open balance
       */
      showPurchaseOrderOpenBalanceOnly = 'showPurchaseOrderOpenBalanceOnly',
      /**
       * show only purchase orders
       */
      purchaseOrderOnly = 'purchaseOrderOnly',
      sort = 'sort',
      farmerId = 'farmerId',
      /**
       * CASH_VIA_COOPERATIVE or CASH_VIA_COLLECTOR or BANK_TRANSFER or UNKNOWN
       */
      wayOfPayment = 'wayOfPayment',
      womensCoffee = 'womensCoffee',
      limit = 'limit',
      offset = 'offset',
      productionDateStart = 'productionDateStart',
      productionDateEnd = 'productionDateEnd',
      /**
       * by farmer name or surname
       */
      query = 'query'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listStockOrdersForOrganization
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListStockOrdersForOrganization.PartialParamMap]?: [string, ValidatorFn][]} = {
      organizationId: [
              ['required', Validators.required],
      ],
      showPurchaseOrderOpenBalanceOnly: [
      ],
      purchaseOrderOnly: [
      ],
      sort: [
      ],
      farmerId: [
      ],
      wayOfPayment: [
      ],
      womensCoffee: [
      ],
      limit: [
      ],
      offset: [
      ],
      productionDateStart: [
      ],
      productionDateEnd: [
      ],
      query: [
      ],
    };
}

/**
 * Namespace for postStockOrder.
 */
export namespace PostStockOrder {
    /**
     * Parameter map for postStockOrder.
     */
    export interface PartialParamMap {
      ChainStockOrder: ChainStockOrder;
    }

    /**
     * Enumeration of all parameters for postStockOrder.
     */
    export enum Parameters {
      ChainStockOrder = 'ChainStockOrder'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postStockOrder
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostStockOrder.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}



@Injectable({
  providedIn: 'root'
})
export class StockOrderService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath != null ? configuration.basePath : (basePath != null ? basePath : this.basePath);
        } else {
            this.configuration.basePath = basePath != null ? basePath : this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }



  /**
   *  by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public availableQuantityOfSemiProductInFacilitiesByMap(
    map: AvailableQuantityOfSemiProductInFacilities.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainSemiProductAvailabilityArray>;
  public availableQuantityOfSemiProductInFacilitiesByMap(
    map: AvailableQuantityOfSemiProductInFacilities.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainSemiProductAvailabilityArray>>;
  public availableQuantityOfSemiProductInFacilitiesByMap(
    map: AvailableQuantityOfSemiProductInFacilities.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainSemiProductAvailabilityArray>>;
  public availableQuantityOfSemiProductInFacilitiesByMap(
    map: AvailableQuantityOfSemiProductInFacilities.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.availableQuantityOfSemiProductInFacilities(
      map.AvailabilityInFacilitiesRequest,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * 
     * @param AvailabilityInFacilitiesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public availableQuantityOfSemiProductInFacilities(AvailabilityInFacilitiesRequest: AvailabilityInFacilitiesRequest, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainSemiProductAvailabilityArray>;
    public availableQuantityOfSemiProductInFacilities(AvailabilityInFacilitiesRequest: AvailabilityInFacilitiesRequest, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainSemiProductAvailabilityArray>>;
    public availableQuantityOfSemiProductInFacilities(AvailabilityInFacilitiesRequest: AvailabilityInFacilitiesRequest, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainSemiProductAvailabilityArray>>;
    public availableQuantityOfSemiProductInFacilities(AvailabilityInFacilitiesRequest: AvailabilityInFacilitiesRequest, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (AvailabilityInFacilitiesRequest === null || AvailabilityInFacilitiesRequest === undefined) {
            throw new Error('Required parameter AvailabilityInFacilitiesRequest was null or undefined when calling availableQuantityOfSemiProductInFacilities.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseChainSemiProductAvailabilityArray>(`${this.configuration.basePath}/chain-api/data/stock-order/availability`,
            AvailabilityInFacilitiesRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'AvailableQuantityOfSemiProductInFacilities')));
        }
        return handle;
    }


  /**
   *  by map.
   * Lists semi-product availability in a facility
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public availableQuantityOfSemiProductInFacilityByMap(
    map: AvailableQuantityOfSemiProductInFacility.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainSemiProductAvailability>;
  public availableQuantityOfSemiProductInFacilityByMap(
    map: AvailableQuantityOfSemiProductInFacility.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainSemiProductAvailability>>;
  public availableQuantityOfSemiProductInFacilityByMap(
    map: AvailableQuantityOfSemiProductInFacility.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainSemiProductAvailability>>;
  public availableQuantityOfSemiProductInFacilityByMap(
    map: AvailableQuantityOfSemiProductInFacility.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.availableQuantityOfSemiProductInFacility(
      map.facilityId,
      map.semiProductId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Lists semi-product availability in a facility
     * @param facilityId 
     * @param semiProductId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public availableQuantityOfSemiProductInFacility(facilityId: string, semiProductId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainSemiProductAvailability>;
    public availableQuantityOfSemiProductInFacility(facilityId: string, semiProductId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainSemiProductAvailability>>;
    public availableQuantityOfSemiProductInFacility(facilityId: string, semiProductId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainSemiProductAvailability>>;
    public availableQuantityOfSemiProductInFacility(facilityId: string, semiProductId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (facilityId === null || facilityId === undefined) {
            throw new Error('Required parameter facilityId was null or undefined when calling availableQuantityOfSemiProductInFacility.');
        }
        if (semiProductId === null || semiProductId === undefined) {
            throw new Error('Required parameter semiProductId was null or undefined when calling availableQuantityOfSemiProductInFacility.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainSemiProductAvailability>(`${this.configuration.basePath}/chain-api/data/stock-order/availability/facility/${encodeURIComponent(String(facilityId))}/semi-product/${encodeURIComponent(String(semiProductId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'AvailableQuantityOfSemiProductInFacility')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes stock order.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteStockOrderByMap(
    map: DeleteStockOrder.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteStockOrderByMap(
    map: DeleteStockOrder.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteStockOrderByMap(
    map: DeleteStockOrder.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteStockOrderByMap(
    map: DeleteStockOrder.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteStockOrder(
      map.ChainStockOrder,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes stock order.
     * @param ChainStockOrder 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteStockOrder(ChainStockOrder: ChainStockOrder, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteStockOrder(ChainStockOrder: ChainStockOrder, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteStockOrder(ChainStockOrder: ChainStockOrder, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteStockOrder(ChainStockOrder: ChainStockOrder, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainStockOrder === null || ChainStockOrder === undefined) {
            throw new Error('Required parameter ChainStockOrder was null or undefined when calling deleteStockOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/data/stock-order/delete`,
            ChainStockOrder,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteStockOrder')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes stock orders.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteStockOrdersByMap(
    map: DeleteStockOrders.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteStockOrdersByMap(
    map: DeleteStockOrders.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteStockOrdersByMap(
    map: DeleteStockOrders.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteStockOrdersByMap(
    map: DeleteStockOrders.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteStockOrders(
      map.ChainStockOrder,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes stock orders.
     * @param ChainStockOrder 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteStockOrders(ChainStockOrder: Array<ChainStockOrder>, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteStockOrders(ChainStockOrder: Array<ChainStockOrder>, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteStockOrders(ChainStockOrder: Array<ChainStockOrder>, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteStockOrders(ChainStockOrder: Array<ChainStockOrder>, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainStockOrder === null || ChainStockOrder === undefined) {
            throw new Error('Required parameter ChainStockOrder was null or undefined when calling deleteStockOrders.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/data/stock-order/delete-stock-orders`,
            ChainStockOrder,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteStockOrders')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns aggregates for stock order
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAggregatesForStockOrderByMap(
    map: GetAggregatesForStockOrder.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseProcessingOrderHistoryArray>;
  public getAggregatesForStockOrderByMap(
    map: GetAggregatesForStockOrder.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseProcessingOrderHistoryArray>>;
  public getAggregatesForStockOrderByMap(
    map: GetAggregatesForStockOrder.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseProcessingOrderHistoryArray>>;
  public getAggregatesForStockOrderByMap(
    map: GetAggregatesForStockOrder.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getAggregatesForStockOrder(
      map.stockOrderId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns aggregates for stock order
     * @param stockOrderId stock order dbID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAggregatesForStockOrder(stockOrderId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseProcessingOrderHistoryArray>;
    public getAggregatesForStockOrder(stockOrderId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseProcessingOrderHistoryArray>>;
    public getAggregatesForStockOrder(stockOrderId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseProcessingOrderHistoryArray>>;
    public getAggregatesForStockOrder(stockOrderId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (stockOrderId === null || stockOrderId === undefined) {
            throw new Error('Required parameter stockOrderId was null or undefined when calling getAggregatesForStockOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseProcessingOrderHistoryArray>(`${this.configuration.basePath}/chain-api/data/stock-order/aggregates/${encodeURIComponent(String(stockOrderId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetAggregatesForStockOrder')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns B2C relevant data for stock order
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getB2CDataForStockOrderByMap(
    map: GetB2CDataForStockOrder.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public getB2CDataForStockOrderByMap(
    map: GetB2CDataForStockOrder.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public getB2CDataForStockOrderByMap(
    map: GetB2CDataForStockOrder.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public getB2CDataForStockOrderByMap(
    map: GetB2CDataForStockOrder.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getB2CDataForStockOrder(
      map.stockOrderId,
      map.orderId,
      map.cooperative,
      map.cuppingGrade,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns B2C relevant data for stock order
     * @param stockOrderId stock order dbID
     * @param orderId 
     * @param cooperative 
     * @param cuppingGrade 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getB2CDataForStockOrder(stockOrderId: string, orderId?: boolean, cooperative?: boolean, cuppingGrade?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public getB2CDataForStockOrder(stockOrderId: string, orderId?: boolean, cooperative?: boolean, cuppingGrade?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public getB2CDataForStockOrder(stockOrderId: string, orderId?: boolean, cooperative?: boolean, cuppingGrade?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public getB2CDataForStockOrder(stockOrderId: string, orderId?: boolean, cooperative?: boolean, cuppingGrade?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (stockOrderId === null || stockOrderId === undefined) {
            throw new Error('Required parameter stockOrderId was null or undefined when calling getB2CDataForStockOrder.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (orderId !== undefined && orderId !== null) {
            queryParameters = queryParameters.set('orderId', <any>orderId);
        }
        if (cooperative !== undefined && cooperative !== null) {
            queryParameters = queryParameters.set('cooperative', <any>cooperative);
        }
        if (cuppingGrade !== undefined && cuppingGrade !== null) {
            queryParameters = queryParameters.set('cuppingGrade', <any>cuppingGrade);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseAny>(`${this.configuration.basePath}/chain-api/data/stock-order/b2c/${encodeURIComponent(String(stockOrderId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetB2CDataForStockOrder')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns seasonal statistics
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSeasonalStatisticsForOrganizationByMap(
    map: GetSeasonalStatisticsForOrganization.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public getSeasonalStatisticsForOrganizationByMap(
    map: GetSeasonalStatisticsForOrganization.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public getSeasonalStatisticsForOrganizationByMap(
    map: GetSeasonalStatisticsForOrganization.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public getSeasonalStatisticsForOrganizationByMap(
    map: GetSeasonalStatisticsForOrganization.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getSeasonalStatisticsForOrganization(
      map.organizationId,
      map.fromDate,
      map.toDate,
      map.specificOrder,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns seasonal statistics
     * @param organizationId stock order dbID
     * @param fromDate 
     * @param toDate 
     * @param specificOrder 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSeasonalStatisticsForOrganization(organizationId: string, fromDate: string, toDate: string, specificOrder?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public getSeasonalStatisticsForOrganization(organizationId: string, fromDate: string, toDate: string, specificOrder?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public getSeasonalStatisticsForOrganization(organizationId: string, fromDate: string, toDate: string, specificOrder?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public getSeasonalStatisticsForOrganization(organizationId: string, fromDate: string, toDate: string, specificOrder?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getSeasonalStatisticsForOrganization.');
        }
        if (fromDate === null || fromDate === undefined) {
            throw new Error('Required parameter fromDate was null or undefined when calling getSeasonalStatisticsForOrganization.');
        }
        if (toDate === null || toDate === undefined) {
            throw new Error('Required parameter toDate was null or undefined when calling getSeasonalStatisticsForOrganization.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromDate !== undefined && fromDate !== null) {
            queryParameters = queryParameters.set('fromDate', <any>fromDate);
        }
        if (toDate !== undefined && toDate !== null) {
            queryParameters = queryParameters.set('toDate', <any>toDate);
        }
        if (specificOrder !== undefined && specificOrder !== null) {
            queryParameters = queryParameters.set('specificOrder', <any>specificOrder);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseAny>(`${this.configuration.basePath}/chain-api/data/stock-order/seasonalStatistics/${encodeURIComponent(String(organizationId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetSeasonalStatisticsForOrganization')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a stock order by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getStockOrderByIdByMap(
    map: GetStockOrderById.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainStockOrder>;
  public getStockOrderByIdByMap(
    map: GetStockOrderById.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainStockOrder>>;
  public getStockOrderByIdByMap(
    map: GetStockOrderById.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainStockOrder>>;
  public getStockOrderByIdByMap(
    map: GetStockOrderById.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getStockOrderById(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a stock order by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStockOrderById(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainStockOrder>;
    public getStockOrderById(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainStockOrder>>;
    public getStockOrderById(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainStockOrder>>;
    public getStockOrderById(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getStockOrderById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetStockOrderById')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a stock order by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getStockOrderByIdWithInputOrdersByMap(
    map: GetStockOrderByIdWithInputOrders.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainStockOrder>;
  public getStockOrderByIdWithInputOrdersByMap(
    map: GetStockOrderByIdWithInputOrders.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainStockOrder>>;
  public getStockOrderByIdWithInputOrdersByMap(
    map: GetStockOrderByIdWithInputOrders.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainStockOrder>>;
  public getStockOrderByIdWithInputOrdersByMap(
    map: GetStockOrderByIdWithInputOrders.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getStockOrderByIdWithInputOrders(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a stock order by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStockOrderByIdWithInputOrders(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainStockOrder>;
    public getStockOrderByIdWithInputOrders(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainStockOrder>>;
    public getStockOrderByIdWithInputOrders(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainStockOrder>>;
    public getStockOrderByIdWithInputOrders(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getStockOrderByIdWithInputOrders.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/${encodeURIComponent(String(dbId))}/with-input-orders`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetStockOrderByIdWithInputOrders')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns a paginated list of stock orders in a given facility
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listAvailableStockForFacilityByMap(
    map: ListAvailableStockForFacility.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listAvailableStockForFacilityByMap(
    map: ListAvailableStockForFacility.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listAvailableStockForFacilityByMap(
    map: ListAvailableStockForFacility.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listAvailableStockForFacilityByMap(
    map: ListAvailableStockForFacility.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listAvailableStockForFacility(
      map.facilityId,
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns a paginated list of stock orders in a given facility
     * @param facilityId _id of a given facility
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listAvailableStockForFacility(facilityId: string, sort?: any, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listAvailableStockForFacility(facilityId: string, sort?: any, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listAvailableStockForFacility(facilityId: string, sort?: any, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listAvailableStockForFacility(facilityId: string, sort?: any, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (facilityId === null || facilityId === undefined) {
            throw new Error('Required parameter facilityId was null or undefined when calling listAvailableStockForFacility.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/facility/${encodeURIComponent(String(facilityId))}/available`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListAvailableStockForFacility')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns a paginated list of stock orders with certain semi-product id in a given facility
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listAvailableStockForSemiProductInFacilityByMap(
    map: ListAvailableStockForSemiProductInFacility.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listAvailableStockForSemiProductInFacilityByMap(
    map: ListAvailableStockForSemiProductInFacility.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listAvailableStockForSemiProductInFacilityByMap(
    map: ListAvailableStockForSemiProductInFacility.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listAvailableStockForSemiProductInFacilityByMap(
    map: ListAvailableStockForSemiProductInFacility.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listAvailableStockForSemiProductInFacility(
      map.facilityId,
      map.semiProductId,
      map.womensCoffee,
      map.productionDateStart,
      map.productionDateEnd,
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns a paginated list of stock orders with certain semi-product id in a given facility
     * @param facilityId _id of a given facility
     * @param semiProductId _id of a desired semi-product
     * @param womensCoffee 
     * @param productionDateStart 
     * @param productionDateEnd 
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listAvailableStockForSemiProductInFacility(facilityId: string, semiProductId: string, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, sort?: any, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listAvailableStockForSemiProductInFacility(facilityId: string, semiProductId: string, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, sort?: any, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listAvailableStockForSemiProductInFacility(facilityId: string, semiProductId: string, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, sort?: any, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listAvailableStockForSemiProductInFacility(facilityId: string, semiProductId: string, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, sort?: any, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (facilityId === null || facilityId === undefined) {
            throw new Error('Required parameter facilityId was null or undefined when calling listAvailableStockForSemiProductInFacility.');
        }
        if (semiProductId === null || semiProductId === undefined) {
            throw new Error('Required parameter semiProductId was null or undefined when calling listAvailableStockForSemiProductInFacility.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (womensCoffee !== undefined && womensCoffee !== null) {
            queryParameters = queryParameters.set('womensCoffee', <any>womensCoffee);
        }
        if (productionDateStart !== undefined && productionDateStart !== null) {
            queryParameters = queryParameters.set('productionDateStart', <any>productionDateStart);
        }
        if (productionDateEnd !== undefined && productionDateEnd !== null) {
            queryParameters = queryParameters.set('productionDateEnd', <any>productionDateEnd);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/facility/${encodeURIComponent(String(facilityId))}/semi-product/${encodeURIComponent(String(semiProductId))}/available`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListAvailableStockForSemiProductInFacility')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns a paginated list of all stock orders
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listPurchaseOrderForUserCustomerByMap(
    map: ListPurchaseOrderForUserCustomer.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listPurchaseOrderForUserCustomerByMap(
    map: ListPurchaseOrderForUserCustomer.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listPurchaseOrderForUserCustomerByMap(
    map: ListPurchaseOrderForUserCustomer.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listPurchaseOrderForUserCustomerByMap(
    map: ListPurchaseOrderForUserCustomer.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listPurchaseOrderForUserCustomer(
      map.farmerId,
      map.showOpenBalanceOnly,
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns a paginated list of all stock orders
     * @param farmerId userCustomerId
     * @param showOpenBalanceOnly 
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listPurchaseOrderForUserCustomer(farmerId: string, showOpenBalanceOnly?: boolean, sort?: any, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listPurchaseOrderForUserCustomer(farmerId: string, showOpenBalanceOnly?: boolean, sort?: any, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listPurchaseOrderForUserCustomer(farmerId: string, showOpenBalanceOnly?: boolean, sort?: any, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listPurchaseOrderForUserCustomer(farmerId: string, showOpenBalanceOnly?: boolean, sort?: any, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (farmerId === null || farmerId === undefined) {
            throw new Error('Required parameter farmerId was null or undefined when calling listPurchaseOrderForUserCustomer.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (showOpenBalanceOnly !== undefined && showOpenBalanceOnly !== null) {
            queryParameters = queryParameters.set('showOpenBalanceOnly', <any>showOpenBalanceOnly);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/farmer/${encodeURIComponent(String(farmerId))}/purchase-orders`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListPurchaseOrderForUserCustomer')));
        }
        return handle;
    }


  /**
   *  by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listQuoteOrdersByMap(
    map: ListQuoteOrders.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listQuoteOrdersByMap(
    map: ListQuoteOrders.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listQuoteOrdersByMap(
    map: ListQuoteOrders.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listQuoteOrdersByMap(
    map: ListQuoteOrders.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listQuoteOrders(
      map.facilityOrOrganizationId,
      map.openOnly,
      map.semiProductId,
      map.mode,
      map.sort,
      map.sortBy,
      map.limit,
      map.offset,
      map.productionDateStart,
      map.productionDateEnd,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * 
     * @param facilityOrOrganizationId 
     * @param openOnly 
     * @param semiProductId 
     * @param mode 
     * @param sort 
     * @param sortBy 
     * @param limit 
     * @param offset 
     * @param productionDateStart 
     * @param productionDateEnd 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listQuoteOrders(facilityOrOrganizationId: string, openOnly: boolean, semiProductId?: string, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listQuoteOrders(facilityOrOrganizationId: string, openOnly: boolean, semiProductId?: string, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listQuoteOrders(facilityOrOrganizationId: string, openOnly: boolean, semiProductId?: string, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listQuoteOrders(facilityOrOrganizationId: string, openOnly: boolean, semiProductId?: string, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (facilityOrOrganizationId === null || facilityOrOrganizationId === undefined) {
            throw new Error('Required parameter facilityOrOrganizationId was null or undefined when calling listQuoteOrders.');
        }
        if (openOnly === null || openOnly === undefined) {
            throw new Error('Required parameter openOnly was null or undefined when calling listQuoteOrders.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (openOnly !== undefined && openOnly !== null) {
            queryParameters = queryParameters.set('openOnly', <any>openOnly);
        }
        if (semiProductId !== undefined && semiProductId !== null) {
            queryParameters = queryParameters.set('semiProductId', <any>semiProductId);
        }
        if (mode !== undefined && mode !== null) {
            queryParameters = queryParameters.set('mode', <any>mode);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (productionDateStart !== undefined && productionDateStart !== null) {
            queryParameters = queryParameters.set('productionDateStart', <any>productionDateStart);
        }
        if (productionDateEnd !== undefined && productionDateEnd !== null) {
            queryParameters = queryParameters.set('productionDateEnd', <any>productionDateEnd);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/facility/${encodeURIComponent(String(facilityOrOrganizationId))}/list-quotes`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListQuoteOrders')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns a paginated list of all stock orders in a given facility
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listStockForFacilityByMap(
    map: ListStockForFacility.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listStockForFacilityByMap(
    map: ListStockForFacility.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listStockForFacilityByMap(
    map: ListStockForFacility.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listStockForFacilityByMap(
    map: ListStockForFacility.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listStockForFacility(
      map.facilityId,
      map.showPurchaseOrderOpenBalanceOnly,
      map.purchaseOrderOnly,
      map.availableOnly,
      map.semiProductId,
      map.wayOfPayment,
      map.sort,
      map.sortBy,
      map.limit,
      map.offset,
      map.womensCoffee,
      map.productionDateStart,
      map.productionDateEnd,
      map.query,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns a paginated list of all stock orders in a given facility
     * @param facilityId _id of a given facility
     * @param showPurchaseOrderOpenBalanceOnly show purhcase orders with open balance
     * @param purchaseOrderOnly show only purchase orders
     * @param availableOnly 
     * @param semiProductId 
     * @param wayOfPayment CASH_VIA_COOPERATIVE or CASH_VIA_COLLECTOR or BANK_TRANSFER or UNKNOWN
     * @param sort sort order ASC or DESC
     * @param sortBy 
     * @param limit query limit
     * @param offset query offset
     * @param womensCoffee 
     * @param productionDateStart 
     * @param productionDateEnd 
     * @param query by farmer name or surname
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listStockForFacility(facilityId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, availableOnly?: boolean, semiProductId?: string, wayOfPayment?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, query?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listStockForFacility(facilityId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, availableOnly?: boolean, semiProductId?: string, wayOfPayment?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, query?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listStockForFacility(facilityId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, availableOnly?: boolean, semiProductId?: string, wayOfPayment?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, query?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listStockForFacility(facilityId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, availableOnly?: boolean, semiProductId?: string, wayOfPayment?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, womensCoffee?: boolean, productionDateStart?: string, productionDateEnd?: string, query?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (facilityId === null || facilityId === undefined) {
            throw new Error('Required parameter facilityId was null or undefined when calling listStockForFacility.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (showPurchaseOrderOpenBalanceOnly !== undefined && showPurchaseOrderOpenBalanceOnly !== null) {
            queryParameters = queryParameters.set('showPurchaseOrderOpenBalanceOnly', <any>showPurchaseOrderOpenBalanceOnly);
        }
        if (purchaseOrderOnly !== undefined && purchaseOrderOnly !== null) {
            queryParameters = queryParameters.set('purchaseOrderOnly', <any>purchaseOrderOnly);
        }
        if (availableOnly !== undefined && availableOnly !== null) {
            queryParameters = queryParameters.set('availableOnly', <any>availableOnly);
        }
        if (semiProductId !== undefined && semiProductId !== null) {
            queryParameters = queryParameters.set('semiProductId', <any>semiProductId);
        }
        if (wayOfPayment !== undefined && wayOfPayment !== null) {
            queryParameters = queryParameters.set('wayOfPayment', <any>wayOfPayment);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (womensCoffee !== undefined && womensCoffee !== null) {
            queryParameters = queryParameters.set('womensCoffee', <any>womensCoffee);
        }
        if (productionDateStart !== undefined && productionDateStart !== null) {
            queryParameters = queryParameters.set('productionDateStart', <any>productionDateStart);
        }
        if (productionDateEnd !== undefined && productionDateEnd !== null) {
            queryParameters = queryParameters.set('productionDateEnd', <any>productionDateEnd);
        }
        if (query !== undefined && query !== null) {
            queryParameters = queryParameters.set('query', <any>query);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/facility/${encodeURIComponent(String(facilityId))}/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListStockForFacility')));
        }
        return handle;
    }


  /**
   *  by map.
   * Lists stock orders in facility filtered optionaly by specific customer and possibly only open
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listStockInFacilityForCustomersByMap(
    map: ListStockInFacilityForCustomers.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listStockInFacilityForCustomersByMap(
    map: ListStockInFacilityForCustomers.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listStockInFacilityForCustomersByMap(
    map: ListStockInFacilityForCustomers.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listStockInFacilityForCustomersByMap(
    map: ListStockInFacilityForCustomers.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listStockInFacilityForCustomers(
      map.facilityOrOrganizationId,
      map.companyCustomerId,
      map.openOnly,
      map.mode,
      map.sort,
      map.sortBy,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Lists stock orders in facility filtered optionaly by specific customer and possibly only open
     * @param facilityOrOrganizationId 
     * @param companyCustomerId 
     * @param openOnly 
     * @param mode 
     * @param sort 
     * @param sortBy 
     * @param limit 
     * @param offset 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listStockInFacilityForCustomers(facilityOrOrganizationId: string, companyCustomerId?: string, openOnly?: boolean, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listStockInFacilityForCustomers(facilityOrOrganizationId: string, companyCustomerId?: string, openOnly?: boolean, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listStockInFacilityForCustomers(facilityOrOrganizationId: string, companyCustomerId?: string, openOnly?: boolean, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listStockInFacilityForCustomers(facilityOrOrganizationId: string, companyCustomerId?: string, openOnly?: boolean, mode?: any, sort?: any, sortBy?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (facilityOrOrganizationId === null || facilityOrOrganizationId === undefined) {
            throw new Error('Required parameter facilityOrOrganizationId was null or undefined when calling listStockInFacilityForCustomers.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (companyCustomerId !== undefined && companyCustomerId !== null) {
            queryParameters = queryParameters.set('companyCustomerId', <any>companyCustomerId);
        }
        if (openOnly !== undefined && openOnly !== null) {
            queryParameters = queryParameters.set('openOnly', <any>openOnly);
        }
        if (mode !== undefined && mode !== null) {
            queryParameters = queryParameters.set('mode', <any>mode);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/facility/${encodeURIComponent(String(facilityOrOrganizationId))}/orders-for-customers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListStockInFacilityForCustomers')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns a paginated list of all stock orders
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listStockOrdersByMap(
    map: ListStockOrders.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listStockOrdersByMap(
    map: ListStockOrders.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listStockOrdersByMap(
    map: ListStockOrders.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listStockOrdersByMap(
    map: ListStockOrders.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listStockOrders(
      map.showPurchaseOrderOpenBalanceOnly,
      map.purchaseOrderOnly,
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns a paginated list of all stock orders
     * @param showPurchaseOrderOpenBalanceOnly show purhcase orders with open balance
     * @param purchaseOrderOnly show only purchase orders
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listStockOrders(showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listStockOrders(showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listStockOrders(showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listStockOrders(showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (showPurchaseOrderOpenBalanceOnly !== undefined && showPurchaseOrderOpenBalanceOnly !== null) {
            queryParameters = queryParameters.set('showPurchaseOrderOpenBalanceOnly', <any>showPurchaseOrderOpenBalanceOnly);
        }
        if (purchaseOrderOnly !== undefined && purchaseOrderOnly !== null) {
            queryParameters = queryParameters.set('purchaseOrderOnly', <any>purchaseOrderOnly);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListStockOrders')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns a list of all stock orders for organizationId
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listStockOrdersForOrganizationByMap(
    map: ListStockOrdersForOrganization.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainStockOrder>;
  public listStockOrdersForOrganizationByMap(
    map: ListStockOrdersForOrganization.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
  public listStockOrdersForOrganizationByMap(
    map: ListStockOrdersForOrganization.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
  public listStockOrdersForOrganizationByMap(
    map: ListStockOrdersForOrganization.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listStockOrdersForOrganization(
      map.organizationId,
      map.showPurchaseOrderOpenBalanceOnly,
      map.purchaseOrderOnly,
      map.sort,
      map.farmerId,
      map.wayOfPayment,
      map.womensCoffee,
      map.limit,
      map.offset,
      map.productionDateStart,
      map.productionDateEnd,
      map.query,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns a list of all stock orders for organizationId
     * @param organizationId organizationId
     * @param showPurchaseOrderOpenBalanceOnly show purhcase orders with open balance
     * @param purchaseOrderOnly show only purchase orders
     * @param sort 
     * @param farmerId 
     * @param wayOfPayment CASH_VIA_COOPERATIVE or CASH_VIA_COLLECTOR or BANK_TRANSFER or UNKNOWN
     * @param womensCoffee 
     * @param limit 
     * @param offset 
     * @param productionDateStart 
     * @param productionDateEnd 
     * @param query by farmer name or surname
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listStockOrdersForOrganization(organizationId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, farmerId?: string, wayOfPayment?: any, womensCoffee?: boolean, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, query?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainStockOrder>;
    public listStockOrdersForOrganization(organizationId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, farmerId?: string, wayOfPayment?: any, womensCoffee?: boolean, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, query?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainStockOrder>>;
    public listStockOrdersForOrganization(organizationId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, farmerId?: string, wayOfPayment?: any, womensCoffee?: boolean, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, query?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainStockOrder>>;
    public listStockOrdersForOrganization(organizationId: string, showPurchaseOrderOpenBalanceOnly?: boolean, purchaseOrderOnly?: boolean, sort?: any, farmerId?: string, wayOfPayment?: any, womensCoffee?: boolean, limit?: number, offset?: number, productionDateStart?: string, productionDateEnd?: string, query?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling listStockOrdersForOrganization.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (showPurchaseOrderOpenBalanceOnly !== undefined && showPurchaseOrderOpenBalanceOnly !== null) {
            queryParameters = queryParameters.set('showPurchaseOrderOpenBalanceOnly', <any>showPurchaseOrderOpenBalanceOnly);
        }
        if (purchaseOrderOnly !== undefined && purchaseOrderOnly !== null) {
            queryParameters = queryParameters.set('purchaseOrderOnly', <any>purchaseOrderOnly);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (farmerId !== undefined && farmerId !== null) {
            queryParameters = queryParameters.set('farmerId', <any>farmerId);
        }
        if (wayOfPayment !== undefined && wayOfPayment !== null) {
            queryParameters = queryParameters.set('wayOfPayment', <any>wayOfPayment);
        }
        if (womensCoffee !== undefined && womensCoffee !== null) {
            queryParameters = queryParameters.set('womensCoffee', <any>womensCoffee);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (productionDateStart !== undefined && productionDateStart !== null) {
            queryParameters = queryParameters.set('productionDateStart', <any>productionDateStart);
        }
        if (productionDateEnd !== undefined && productionDateEnd !== null) {
            queryParameters = queryParameters.set('productionDateEnd', <any>productionDateEnd);
        }
        if (query !== undefined && query !== null) {
            queryParameters = queryParameters.set('query', <any>query);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainStockOrder>(`${this.configuration.basePath}/chain-api/data/stock-order/organization/${encodeURIComponent(String(organizationId))}/all`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'ListStockOrdersForOrganization')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates a stock order. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postStockOrderByMap(
    map: PostStockOrder.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postStockOrderByMap(
    map: PostStockOrder.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postStockOrderByMap(
    map: PostStockOrder.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postStockOrderByMap(
    map: PostStockOrder.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postStockOrder(
      map.ChainStockOrder,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates a stock order. When inserting fields _id, _rev and docType should not be present.
     * @param ChainStockOrder 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postStockOrder(ChainStockOrder: ChainStockOrder, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postStockOrder(ChainStockOrder: ChainStockOrder, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postStockOrder(ChainStockOrder: ChainStockOrder, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postStockOrder(ChainStockOrder: ChainStockOrder, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainStockOrder === null || ChainStockOrder === undefined) {
            throw new Error('Required parameter ChainStockOrder was null or undefined when calling postStockOrder.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/data/stock-order`,
            ChainStockOrder,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostStockOrder')));
        }
        return handle;
    }

}
