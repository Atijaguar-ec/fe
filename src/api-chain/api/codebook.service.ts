/*
 * Copyright(c) 2009 - 2019 Abelium d.o.o.
 * Kajuhova 90, 1000 Ljubljana, Slovenia
 * All rights reserved
 * Copyright(c) 1995 - 2018 T-Systems Multimedia Solutions GmbH
 * Riesaer Str. 5, 01129 Dresden
 * All rights reserved.
 *
 * coffee-be
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the openapi-typescript-angular-generator.
 * https://github.com/alenabelium/openapi-typescript-angular-generator
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { ValidatorFn, Validators } from '@angular/forms';

import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import { catchError }                                        from 'rxjs/operators';

import { ApiResponseAny } from '../model/apiResponseAny';
import { ApiResponseChainActionType } from '../model/apiResponseChainActionType';
import { ApiResponseChainFacilityType } from '../model/apiResponseChainFacilityType';
import { ApiResponseChainGradeAbbreviation } from '../model/apiResponseChainGradeAbbreviation';
import { ApiResponseChainMeasureUnitType } from '../model/apiResponseChainMeasureUnitType';
import { ApiResponseChainOrderEvidenceType } from '../model/apiResponseChainOrderEvidenceType';
import { ApiResponseChainProcessingEvidenceType } from '../model/apiResponseChainProcessingEvidenceType';
import { ApiResponsePaginatedListChainActionType } from '../model/apiResponsePaginatedListChainActionType';
import { ApiResponsePaginatedListChainFacilityType } from '../model/apiResponsePaginatedListChainFacilityType';
import { ApiResponsePaginatedListChainGradeAbbreviation } from '../model/apiResponsePaginatedListChainGradeAbbreviation';
import { ApiResponsePaginatedListChainMeasureUnitType } from '../model/apiResponsePaginatedListChainMeasureUnitType';
import { ApiResponsePaginatedListChainOrderEvidenceType } from '../model/apiResponsePaginatedListChainOrderEvidenceType';
import { ApiResponsePaginatedListChainProcessingEvidenceType } from '../model/apiResponsePaginatedListChainProcessingEvidenceType';
import { ChainActionType } from '../model/chainActionType';
import { ChainFacilityType } from '../model/chainFacilityType';
import { ChainGradeAbbreviation } from '../model/chainGradeAbbreviation';
import { ChainMeasureUnitType } from '../model/chainMeasureUnitType';
import { ChainOrderEvidenceType } from '../model/chainOrderEvidenceType';
import { ChainProcessingEvidenceType } from '../model/chainProcessingEvidenceType';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/**
 * Namespace for deleteActionType.
 */
export namespace DeleteActionType {
    /**
     * Parameter map for deleteActionType.
     */
    export interface PartialParamMap {
      ChainActionType: ChainActionType;
    }

    /**
     * Enumeration of all parameters for deleteActionType.
     */
    export enum Parameters {
      ChainActionType = 'ChainActionType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteActionType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteActionType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteFacilityType.
 */
export namespace DeleteFacilityType {
    /**
     * Parameter map for deleteFacilityType.
     */
    export interface PartialParamMap {
      ChainFacilityType: ChainFacilityType;
    }

    /**
     * Enumeration of all parameters for deleteFacilityType.
     */
    export enum Parameters {
      ChainFacilityType = 'ChainFacilityType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteFacilityType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteFacilityType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteGradeAbbreviation.
 */
export namespace DeleteGradeAbbreviation {
    /**
     * Parameter map for deleteGradeAbbreviation.
     */
    export interface PartialParamMap {
      ChainGradeAbbreviation: ChainGradeAbbreviation;
    }

    /**
     * Enumeration of all parameters for deleteGradeAbbreviation.
     */
    export enum Parameters {
      ChainGradeAbbreviation = 'ChainGradeAbbreviation'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteGradeAbbreviation
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteGradeAbbreviation.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteMeasureUnitType.
 */
export namespace DeleteMeasureUnitType {
    /**
     * Parameter map for deleteMeasureUnitType.
     */
    export interface PartialParamMap {
      ChainMeasureUnitType: ChainMeasureUnitType;
    }

    /**
     * Enumeration of all parameters for deleteMeasureUnitType.
     */
    export enum Parameters {
      ChainMeasureUnitType = 'ChainMeasureUnitType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteMeasureUnitType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteMeasureUnitType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteOrderEvidenceType.
 */
export namespace DeleteOrderEvidenceType {
    /**
     * Parameter map for deleteOrderEvidenceType.
     */
    export interface PartialParamMap {
      ChainOrderEvidenceType: ChainOrderEvidenceType;
    }

    /**
     * Enumeration of all parameters for deleteOrderEvidenceType.
     */
    export enum Parameters {
      ChainOrderEvidenceType = 'ChainOrderEvidenceType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteOrderEvidenceType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteOrderEvidenceType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteProcessingEvidenceType.
 */
export namespace DeleteProcessingEvidenceType {
    /**
     * Parameter map for deleteProcessingEvidenceType.
     */
    export interface PartialParamMap {
      ChainProcessingEvidenceType: ChainProcessingEvidenceType;
    }

    /**
     * Enumeration of all parameters for deleteProcessingEvidenceType.
     */
    export enum Parameters {
      ChainProcessingEvidenceType = 'ChainProcessingEvidenceType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProcessingEvidenceType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProcessingEvidenceType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for getActionType.
 */
export namespace GetActionType {
    /**
     * Parameter map for getActionType.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getActionType.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getActionType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetActionType.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getActionTypeList.
 */
export namespace GetActionTypeList {
    /**
     * Parameter map for getActionTypeList.
     */
    export interface PartialParamMap {
      /**
       * sort order ASC or DESC
       */
      sort?: 'ASC' | 'DESC';
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for getActionTypeList.
     */
    export enum Parameters {
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getActionTypeList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetActionTypeList.PartialParamMap]?: [string, ValidatorFn][]} = {
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for getFacilityType.
 */
export namespace GetFacilityType {
    /**
     * Parameter map for getFacilityType.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getFacilityType.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getFacilityType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetFacilityType.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getFacilityTypeList.
 */
export namespace GetFacilityTypeList {
    /**
     * Parameter map for getFacilityTypeList.
     */
    export interface PartialParamMap {
      /**
       * sort order ASC or DESC
       */
      sort?: 'ASC' | 'DESC';
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for getFacilityTypeList.
     */
    export enum Parameters {
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getFacilityTypeList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetFacilityTypeList.PartialParamMap]?: [string, ValidatorFn][]} = {
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for getGradeAbbreviation.
 */
export namespace GetGradeAbbreviation {
    /**
     * Parameter map for getGradeAbbreviation.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getGradeAbbreviation.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getGradeAbbreviation
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetGradeAbbreviation.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getGradeAbbreviationList.
 */
export namespace GetGradeAbbreviationList {
    /**
     * Parameter map for getGradeAbbreviationList.
     */
    export interface PartialParamMap {
      /**
       * sort order ASC or DESC
       */
      sort?: 'ASC' | 'DESC';
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for getGradeAbbreviationList.
     */
    export enum Parameters {
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getGradeAbbreviationList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetGradeAbbreviationList.PartialParamMap]?: [string, ValidatorFn][]} = {
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for getMeasureUnitType.
 */
export namespace GetMeasureUnitType {
    /**
     * Parameter map for getMeasureUnitType.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getMeasureUnitType.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getMeasureUnitType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetMeasureUnitType.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getMeasureUnitTypeList.
 */
export namespace GetMeasureUnitTypeList {
    /**
     * Parameter map for getMeasureUnitTypeList.
     */
    export interface PartialParamMap {
      /**
       * sort order ASC or DESC
       */
      sort?: 'ASC' | 'DESC';
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for getMeasureUnitTypeList.
     */
    export enum Parameters {
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getMeasureUnitTypeList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetMeasureUnitTypeList.PartialParamMap]?: [string, ValidatorFn][]} = {
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for getOrderEvidenceType.
 */
export namespace GetOrderEvidenceType {
    /**
     * Parameter map for getOrderEvidenceType.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getOrderEvidenceType.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getOrderEvidenceType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetOrderEvidenceType.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getOrderEvidenceTypeList.
 */
export namespace GetOrderEvidenceTypeList {
    /**
     * Parameter map for getOrderEvidenceTypeList.
     */
    export interface PartialParamMap {
      /**
       * sort order ASC or DESC
       */
      sort?: 'ASC' | 'DESC';
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for getOrderEvidenceTypeList.
     */
    export enum Parameters {
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getOrderEvidenceTypeList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetOrderEvidenceTypeList.PartialParamMap]?: [string, ValidatorFn][]} = {
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for getProcessingEvidenceType.
 */
export namespace GetProcessingEvidenceType {
    /**
     * Parameter map for getProcessingEvidenceType.
     */
    export interface PartialParamMap {
      dbId: string;
    }

    /**
     * Enumeration of all parameters for getProcessingEvidenceType.
     */
    export enum Parameters {
      dbId = 'dbId'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProcessingEvidenceType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProcessingEvidenceType.PartialParamMap]?: [string, ValidatorFn][]} = {
      dbId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProcessingEvidenceTypeList.
 */
export namespace GetProcessingEvidenceTypeList {
    /**
     * Parameter map for getProcessingEvidenceTypeList.
     */
    export interface PartialParamMap {
      /**
       * sort order ASC or DESC
       */
      sort?: 'ASC' | 'DESC';
      /**
       * query limit
       */
      limit?: number;
      /**
       * query offset
       */
      offset?: number;
    }

    /**
     * Enumeration of all parameters for getProcessingEvidenceTypeList.
     */
    export enum Parameters {
      /**
       * sort order ASC or DESC
       */
      sort = 'sort',
      /**
       * query limit
       */
      limit = 'limit',
      /**
       * query offset
       */
      offset = 'offset'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProcessingEvidenceTypeList
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProcessingEvidenceTypeList.PartialParamMap]?: [string, ValidatorFn][]} = {
      sort: [
      ],
      limit: [
      ],
      offset: [
      ],
    };
}

/**
 * Namespace for getTranslationTemplates.
 */
export namespace GetTranslationTemplates {
    /**
     * Parameter map for getTranslationTemplates.
     */
    export interface PartialParamMap {
    }

    /**
     * Enumeration of all parameters for getTranslationTemplates.
     */
    export enum Parameters {
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getTranslationTemplates
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetTranslationTemplates.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for postActionType.
 */
export namespace PostActionType {
    /**
     * Parameter map for postActionType.
     */
    export interface PartialParamMap {
      ChainActionType: ChainActionType;
    }

    /**
     * Enumeration of all parameters for postActionType.
     */
    export enum Parameters {
      ChainActionType = 'ChainActionType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postActionType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostActionType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for postFacilityType.
 */
export namespace PostFacilityType {
    /**
     * Parameter map for postFacilityType.
     */
    export interface PartialParamMap {
      ChainFacilityType: ChainFacilityType;
    }

    /**
     * Enumeration of all parameters for postFacilityType.
     */
    export enum Parameters {
      ChainFacilityType = 'ChainFacilityType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postFacilityType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostFacilityType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for postGradeAbbreviation.
 */
export namespace PostGradeAbbreviation {
    /**
     * Parameter map for postGradeAbbreviation.
     */
    export interface PartialParamMap {
      ChainGradeAbbreviation: ChainGradeAbbreviation;
    }

    /**
     * Enumeration of all parameters for postGradeAbbreviation.
     */
    export enum Parameters {
      ChainGradeAbbreviation = 'ChainGradeAbbreviation'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postGradeAbbreviation
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostGradeAbbreviation.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for postMeasureUnitType.
 */
export namespace PostMeasureUnitType {
    /**
     * Parameter map for postMeasureUnitType.
     */
    export interface PartialParamMap {
      ChainMeasureUnitType: ChainMeasureUnitType;
    }

    /**
     * Enumeration of all parameters for postMeasureUnitType.
     */
    export enum Parameters {
      ChainMeasureUnitType = 'ChainMeasureUnitType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postMeasureUnitType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostMeasureUnitType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for postOrderEvidenceType.
 */
export namespace PostOrderEvidenceType {
    /**
     * Parameter map for postOrderEvidenceType.
     */
    export interface PartialParamMap {
      ChainOrderEvidenceType: ChainOrderEvidenceType;
    }

    /**
     * Enumeration of all parameters for postOrderEvidenceType.
     */
    export enum Parameters {
      ChainOrderEvidenceType = 'ChainOrderEvidenceType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postOrderEvidenceType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostOrderEvidenceType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for postProcessingEvidenceType.
 */
export namespace PostProcessingEvidenceType {
    /**
     * Parameter map for postProcessingEvidenceType.
     */
    export interface PartialParamMap {
      ChainProcessingEvidenceType: ChainProcessingEvidenceType;
    }

    /**
     * Enumeration of all parameters for postProcessingEvidenceType.
     */
    export enum Parameters {
      ChainProcessingEvidenceType = 'ChainProcessingEvidenceType'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of postProcessingEvidenceType
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof PostProcessingEvidenceType.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}



@Injectable({
  providedIn: 'root'
})
export class CodebookService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath != null ? configuration.basePath : (basePath != null ? basePath : this.basePath);
        } else {
            this.configuration.basePath = basePath != null ? basePath : this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }



  /**
   *  by map.
   * Deletes action type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteActionTypeByMap(
    map: DeleteActionType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteActionTypeByMap(
    map: DeleteActionType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteActionTypeByMap(
    map: DeleteActionType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteActionTypeByMap(
    map: DeleteActionType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteActionType(
      map.ChainActionType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes action type.
     * @param ChainActionType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteActionType(ChainActionType: ChainActionType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteActionType(ChainActionType: ChainActionType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteActionType(ChainActionType: ChainActionType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteActionType(ChainActionType: ChainActionType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainActionType === null || ChainActionType === undefined) {
            throw new Error('Required parameter ChainActionType was null or undefined when calling deleteActionType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/action-type/delete`,
            ChainActionType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteActionType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes facility type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteFacilityTypeByMap(
    map: DeleteFacilityType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteFacilityTypeByMap(
    map: DeleteFacilityType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteFacilityTypeByMap(
    map: DeleteFacilityType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteFacilityTypeByMap(
    map: DeleteFacilityType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteFacilityType(
      map.ChainFacilityType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes facility type.
     * @param ChainFacilityType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFacilityType(ChainFacilityType: ChainFacilityType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteFacilityType(ChainFacilityType: ChainFacilityType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteFacilityType(ChainFacilityType: ChainFacilityType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteFacilityType(ChainFacilityType: ChainFacilityType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainFacilityType === null || ChainFacilityType === undefined) {
            throw new Error('Required parameter ChainFacilityType was null or undefined when calling deleteFacilityType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/facility-type/delete`,
            ChainFacilityType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteFacilityType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes grade abbreviation.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteGradeAbbreviationByMap(
    map: DeleteGradeAbbreviation.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteGradeAbbreviationByMap(
    map: DeleteGradeAbbreviation.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteGradeAbbreviationByMap(
    map: DeleteGradeAbbreviation.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteGradeAbbreviationByMap(
    map: DeleteGradeAbbreviation.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteGradeAbbreviation(
      map.ChainGradeAbbreviation,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes grade abbreviation.
     * @param ChainGradeAbbreviation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainGradeAbbreviation === null || ChainGradeAbbreviation === undefined) {
            throw new Error('Required parameter ChainGradeAbbreviation was null or undefined when calling deleteGradeAbbreviation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/grade-abbreviation/delete`,
            ChainGradeAbbreviation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteGradeAbbreviation')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes measure unit type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteMeasureUnitTypeByMap(
    map: DeleteMeasureUnitType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteMeasureUnitTypeByMap(
    map: DeleteMeasureUnitType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteMeasureUnitTypeByMap(
    map: DeleteMeasureUnitType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteMeasureUnitTypeByMap(
    map: DeleteMeasureUnitType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteMeasureUnitType(
      map.ChainMeasureUnitType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes measure unit type.
     * @param ChainMeasureUnitType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainMeasureUnitType === null || ChainMeasureUnitType === undefined) {
            throw new Error('Required parameter ChainMeasureUnitType was null or undefined when calling deleteMeasureUnitType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/measure-unit-type/delete`,
            ChainMeasureUnitType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteMeasureUnitType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes order evidence type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteOrderEvidenceTypeByMap(
    map: DeleteOrderEvidenceType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteOrderEvidenceTypeByMap(
    map: DeleteOrderEvidenceType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteOrderEvidenceTypeByMap(
    map: DeleteOrderEvidenceType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteOrderEvidenceTypeByMap(
    map: DeleteOrderEvidenceType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteOrderEvidenceType(
      map.ChainOrderEvidenceType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes order evidence type.
     * @param ChainOrderEvidenceType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainOrderEvidenceType === null || ChainOrderEvidenceType === undefined) {
            throw new Error('Required parameter ChainOrderEvidenceType was null or undefined when calling deleteOrderEvidenceType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/order-evidence-type/delete`,
            ChainOrderEvidenceType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteOrderEvidenceType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Deletes rocessing evidence type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProcessingEvidenceTypeByMap(
    map: DeleteProcessingEvidenceType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public deleteProcessingEvidenceTypeByMap(
    map: DeleteProcessingEvidenceType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public deleteProcessingEvidenceTypeByMap(
    map: DeleteProcessingEvidenceType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public deleteProcessingEvidenceTypeByMap(
    map: DeleteProcessingEvidenceType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProcessingEvidenceType(
      map.ChainProcessingEvidenceType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Deletes rocessing evidence type.
     * @param ChainProcessingEvidenceType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public deleteProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public deleteProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public deleteProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainProcessingEvidenceType === null || ChainProcessingEvidenceType === undefined) {
            throw new Error('Required parameter ChainProcessingEvidenceType was null or undefined when calling deleteProcessingEvidenceType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/processing-evidence-type/delete`,
            ChainProcessingEvidenceType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'DeleteProcessingEvidenceType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches an action type by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getActionTypeByMap(
    map: GetActionType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainActionType>;
  public getActionTypeByMap(
    map: GetActionType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainActionType>>;
  public getActionTypeByMap(
    map: GetActionType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainActionType>>;
  public getActionTypeByMap(
    map: GetActionType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getActionType(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches an action type by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getActionType(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainActionType>;
    public getActionType(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainActionType>>;
    public getActionType(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainActionType>>;
    public getActionType(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getActionType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainActionType>(`${this.configuration.basePath}/chain-api/codebook/action-type/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetActionType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns paginated list of action types.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getActionTypeListByMap(
    map: GetActionTypeList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainActionType>;
  public getActionTypeListByMap(
    map: GetActionTypeList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainActionType>>;
  public getActionTypeListByMap(
    map: GetActionTypeList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainActionType>>;
  public getActionTypeListByMap(
    map: GetActionTypeList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getActionTypeList(
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns paginated list of action types.
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getActionTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainActionType>;
    public getActionTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainActionType>>;
    public getActionTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainActionType>>;
    public getActionTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainActionType>(`${this.configuration.basePath}/chain-api/codebook/action-type/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetActionTypeList')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a facility type by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFacilityTypeByMap(
    map: GetFacilityType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainFacilityType>;
  public getFacilityTypeByMap(
    map: GetFacilityType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainFacilityType>>;
  public getFacilityTypeByMap(
    map: GetFacilityType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainFacilityType>>;
  public getFacilityTypeByMap(
    map: GetFacilityType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getFacilityType(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a facility type by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityType(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainFacilityType>;
    public getFacilityType(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainFacilityType>>;
    public getFacilityType(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainFacilityType>>;
    public getFacilityType(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getFacilityType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainFacilityType>(`${this.configuration.basePath}/chain-api/codebook/facility-type/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetFacilityType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns paginated list of facility types.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFacilityTypeListByMap(
    map: GetFacilityTypeList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainFacilityType>;
  public getFacilityTypeListByMap(
    map: GetFacilityTypeList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainFacilityType>>;
  public getFacilityTypeListByMap(
    map: GetFacilityTypeList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainFacilityType>>;
  public getFacilityTypeListByMap(
    map: GetFacilityTypeList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getFacilityTypeList(
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns paginated list of facility types.
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFacilityTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainFacilityType>;
    public getFacilityTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainFacilityType>>;
    public getFacilityTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainFacilityType>>;
    public getFacilityTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainFacilityType>(`${this.configuration.basePath}/chain-api/codebook/facility-type/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetFacilityTypeList')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a grade abbreviation by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getGradeAbbreviationByMap(
    map: GetGradeAbbreviation.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainGradeAbbreviation>;
  public getGradeAbbreviationByMap(
    map: GetGradeAbbreviation.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainGradeAbbreviation>>;
  public getGradeAbbreviationByMap(
    map: GetGradeAbbreviation.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainGradeAbbreviation>>;
  public getGradeAbbreviationByMap(
    map: GetGradeAbbreviation.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getGradeAbbreviation(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a grade abbreviation by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGradeAbbreviation(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainGradeAbbreviation>;
    public getGradeAbbreviation(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainGradeAbbreviation>>;
    public getGradeAbbreviation(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainGradeAbbreviation>>;
    public getGradeAbbreviation(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getGradeAbbreviation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainGradeAbbreviation>(`${this.configuration.basePath}/chain-api/codebook/grade-abbreviation/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetGradeAbbreviation')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns paginated list of grade abbreviations.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getGradeAbbreviationListByMap(
    map: GetGradeAbbreviationList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainGradeAbbreviation>;
  public getGradeAbbreviationListByMap(
    map: GetGradeAbbreviationList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainGradeAbbreviation>>;
  public getGradeAbbreviationListByMap(
    map: GetGradeAbbreviationList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainGradeAbbreviation>>;
  public getGradeAbbreviationListByMap(
    map: GetGradeAbbreviationList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getGradeAbbreviationList(
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns paginated list of grade abbreviations.
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGradeAbbreviationList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainGradeAbbreviation>;
    public getGradeAbbreviationList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainGradeAbbreviation>>;
    public getGradeAbbreviationList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainGradeAbbreviation>>;
    public getGradeAbbreviationList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainGradeAbbreviation>(`${this.configuration.basePath}/chain-api/codebook/grade-abbreviation/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetGradeAbbreviationList')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a measure unit type by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMeasureUnitTypeByMap(
    map: GetMeasureUnitType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainMeasureUnitType>;
  public getMeasureUnitTypeByMap(
    map: GetMeasureUnitType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainMeasureUnitType>>;
  public getMeasureUnitTypeByMap(
    map: GetMeasureUnitType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainMeasureUnitType>>;
  public getMeasureUnitTypeByMap(
    map: GetMeasureUnitType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getMeasureUnitType(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a measure unit type by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMeasureUnitType(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainMeasureUnitType>;
    public getMeasureUnitType(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainMeasureUnitType>>;
    public getMeasureUnitType(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainMeasureUnitType>>;
    public getMeasureUnitType(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getMeasureUnitType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainMeasureUnitType>(`${this.configuration.basePath}/chain-api/codebook/measure-unit-type/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetMeasureUnitType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns paginated list of measure unit types.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMeasureUnitTypeListByMap(
    map: GetMeasureUnitTypeList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainMeasureUnitType>;
  public getMeasureUnitTypeListByMap(
    map: GetMeasureUnitTypeList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainMeasureUnitType>>;
  public getMeasureUnitTypeListByMap(
    map: GetMeasureUnitTypeList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainMeasureUnitType>>;
  public getMeasureUnitTypeListByMap(
    map: GetMeasureUnitTypeList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getMeasureUnitTypeList(
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns paginated list of measure unit types.
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMeasureUnitTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainMeasureUnitType>;
    public getMeasureUnitTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainMeasureUnitType>>;
    public getMeasureUnitTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainMeasureUnitType>>;
    public getMeasureUnitTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainMeasureUnitType>(`${this.configuration.basePath}/chain-api/codebook/measure-unit-type/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetMeasureUnitTypeList')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a order evidence type by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getOrderEvidenceTypeByMap(
    map: GetOrderEvidenceType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainOrderEvidenceType>;
  public getOrderEvidenceTypeByMap(
    map: GetOrderEvidenceType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainOrderEvidenceType>>;
  public getOrderEvidenceTypeByMap(
    map: GetOrderEvidenceType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainOrderEvidenceType>>;
  public getOrderEvidenceTypeByMap(
    map: GetOrderEvidenceType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getOrderEvidenceType(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a order evidence type by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrderEvidenceType(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainOrderEvidenceType>;
    public getOrderEvidenceType(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainOrderEvidenceType>>;
    public getOrderEvidenceType(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainOrderEvidenceType>>;
    public getOrderEvidenceType(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getOrderEvidenceType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainOrderEvidenceType>(`${this.configuration.basePath}/chain-api/codebook/order-evidence-type/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetOrderEvidenceType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns paginated list of order evidence type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getOrderEvidenceTypeListByMap(
    map: GetOrderEvidenceTypeList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainOrderEvidenceType>;
  public getOrderEvidenceTypeListByMap(
    map: GetOrderEvidenceTypeList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainOrderEvidenceType>>;
  public getOrderEvidenceTypeListByMap(
    map: GetOrderEvidenceTypeList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainOrderEvidenceType>>;
  public getOrderEvidenceTypeListByMap(
    map: GetOrderEvidenceTypeList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getOrderEvidenceTypeList(
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns paginated list of order evidence type.
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrderEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainOrderEvidenceType>;
    public getOrderEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainOrderEvidenceType>>;
    public getOrderEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainOrderEvidenceType>>;
    public getOrderEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainOrderEvidenceType>(`${this.configuration.basePath}/chain-api/codebook/order-evidence-type/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetOrderEvidenceTypeList')));
        }
        return handle;
    }


  /**
   *  by map.
   * Fetches a processing evidence type by its _id.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProcessingEvidenceTypeByMap(
    map: GetProcessingEvidenceType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseChainProcessingEvidenceType>;
  public getProcessingEvidenceTypeByMap(
    map: GetProcessingEvidenceType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseChainProcessingEvidenceType>>;
  public getProcessingEvidenceTypeByMap(
    map: GetProcessingEvidenceType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseChainProcessingEvidenceType>>;
  public getProcessingEvidenceTypeByMap(
    map: GetProcessingEvidenceType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProcessingEvidenceType(
      map.dbId,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Fetches a processing evidence type by its _id.
     * @param dbId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessingEvidenceType(dbId: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseChainProcessingEvidenceType>;
    public getProcessingEvidenceType(dbId: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseChainProcessingEvidenceType>>;
    public getProcessingEvidenceType(dbId: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseChainProcessingEvidenceType>>;
    public getProcessingEvidenceType(dbId: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (dbId === null || dbId === undefined) {
            throw new Error('Required parameter dbId was null or undefined when calling getProcessingEvidenceType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseChainProcessingEvidenceType>(`${this.configuration.basePath}/chain-api/codebook/processing-evidence-type/${encodeURIComponent(String(dbId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetProcessingEvidenceType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Returns paginated list of processing evidence type.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProcessingEvidenceTypeListByMap(
    map: GetProcessingEvidenceTypeList.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponsePaginatedListChainProcessingEvidenceType>;
  public getProcessingEvidenceTypeListByMap(
    map: GetProcessingEvidenceTypeList.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponsePaginatedListChainProcessingEvidenceType>>;
  public getProcessingEvidenceTypeListByMap(
    map: GetProcessingEvidenceTypeList.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponsePaginatedListChainProcessingEvidenceType>>;
  public getProcessingEvidenceTypeListByMap(
    map: GetProcessingEvidenceTypeList.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProcessingEvidenceTypeList(
      map.sort,
      map.limit,
      map.offset,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Returns paginated list of processing evidence type.
     * @param sort sort order ASC or DESC
     * @param limit query limit
     * @param offset query offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProcessingEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponsePaginatedListChainProcessingEvidenceType>;
    public getProcessingEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponsePaginatedListChainProcessingEvidenceType>>;
    public getProcessingEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponsePaginatedListChainProcessingEvidenceType>>;
    public getProcessingEvidenceTypeList(sort?: 'ASC' | 'DESC', limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponsePaginatedListChainProcessingEvidenceType>(`${this.configuration.basePath}/chain-api/codebook/processing-evidence-type/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetProcessingEvidenceTypeList')));
        }
        return handle;
    }


  /**
   *  by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getTranslationTemplatesByMap(
    map: GetTranslationTemplates.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<string>;
  public getTranslationTemplatesByMap(
    map: GetTranslationTemplates.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<string>>;
  public getTranslationTemplatesByMap(
    map: GetTranslationTemplates.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<string>>;
  public getTranslationTemplatesByMap(
    map: GetTranslationTemplates.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getTranslationTemplates(
      observe,
      reportProgress
    );
  }


    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTranslationTemplates(observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<string>;
    public getTranslationTemplates(observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<string>>;
    public getTranslationTemplates(observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<string>>;
    public getTranslationTemplates(observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<string>(`${this.configuration.basePath}/chain-api/codebook/translation-templates`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'GetTranslationTemplates')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates an action type. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postActionTypeByMap(
    map: PostActionType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postActionTypeByMap(
    map: PostActionType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postActionTypeByMap(
    map: PostActionType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postActionTypeByMap(
    map: PostActionType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postActionType(
      map.ChainActionType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates an action type. When inserting fields _id, _rev and docType should not be present.
     * @param ChainActionType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postActionType(ChainActionType: ChainActionType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postActionType(ChainActionType: ChainActionType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postActionType(ChainActionType: ChainActionType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postActionType(ChainActionType: ChainActionType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainActionType === null || ChainActionType === undefined) {
            throw new Error('Required parameter ChainActionType was null or undefined when calling postActionType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/action-type`,
            ChainActionType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostActionType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates a facility type. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postFacilityTypeByMap(
    map: PostFacilityType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postFacilityTypeByMap(
    map: PostFacilityType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postFacilityTypeByMap(
    map: PostFacilityType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postFacilityTypeByMap(
    map: PostFacilityType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postFacilityType(
      map.ChainFacilityType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates a facility type. When inserting fields _id, _rev and docType should not be present.
     * @param ChainFacilityType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postFacilityType(ChainFacilityType: ChainFacilityType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postFacilityType(ChainFacilityType: ChainFacilityType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postFacilityType(ChainFacilityType: ChainFacilityType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postFacilityType(ChainFacilityType: ChainFacilityType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainFacilityType === null || ChainFacilityType === undefined) {
            throw new Error('Required parameter ChainFacilityType was null or undefined when calling postFacilityType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/facility-type`,
            ChainFacilityType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostFacilityType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates a grade abbreviation. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postGradeAbbreviationByMap(
    map: PostGradeAbbreviation.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postGradeAbbreviationByMap(
    map: PostGradeAbbreviation.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postGradeAbbreviationByMap(
    map: PostGradeAbbreviation.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postGradeAbbreviationByMap(
    map: PostGradeAbbreviation.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postGradeAbbreviation(
      map.ChainGradeAbbreviation,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates a grade abbreviation. When inserting fields _id, _rev and docType should not be present.
     * @param ChainGradeAbbreviation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postGradeAbbreviation(ChainGradeAbbreviation: ChainGradeAbbreviation, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainGradeAbbreviation === null || ChainGradeAbbreviation === undefined) {
            throw new Error('Required parameter ChainGradeAbbreviation was null or undefined when calling postGradeAbbreviation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/grade-abbreviation`,
            ChainGradeAbbreviation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostGradeAbbreviation')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates a measure unit type. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postMeasureUnitTypeByMap(
    map: PostMeasureUnitType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postMeasureUnitTypeByMap(
    map: PostMeasureUnitType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postMeasureUnitTypeByMap(
    map: PostMeasureUnitType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postMeasureUnitTypeByMap(
    map: PostMeasureUnitType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postMeasureUnitType(
      map.ChainMeasureUnitType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates a measure unit type. When inserting fields _id, _rev and docType should not be present.
     * @param ChainMeasureUnitType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postMeasureUnitType(ChainMeasureUnitType: ChainMeasureUnitType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainMeasureUnitType === null || ChainMeasureUnitType === undefined) {
            throw new Error('Required parameter ChainMeasureUnitType was null or undefined when calling postMeasureUnitType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/measure-unit-type`,
            ChainMeasureUnitType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostMeasureUnitType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates a order evidence type. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postOrderEvidenceTypeByMap(
    map: PostOrderEvidenceType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postOrderEvidenceTypeByMap(
    map: PostOrderEvidenceType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postOrderEvidenceTypeByMap(
    map: PostOrderEvidenceType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postOrderEvidenceTypeByMap(
    map: PostOrderEvidenceType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postOrderEvidenceType(
      map.ChainOrderEvidenceType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates a order evidence type. When inserting fields _id, _rev and docType should not be present.
     * @param ChainOrderEvidenceType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postOrderEvidenceType(ChainOrderEvidenceType: ChainOrderEvidenceType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainOrderEvidenceType === null || ChainOrderEvidenceType === undefined) {
            throw new Error('Required parameter ChainOrderEvidenceType was null or undefined when calling postOrderEvidenceType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/order-evidence-type`,
            ChainOrderEvidenceType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostOrderEvidenceType')));
        }
        return handle;
    }


  /**
   *  by map.
   * Inserts or updates a rocessing evidence type. When inserting fields _id, _rev and docType should not be present.
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postProcessingEvidenceTypeByMap(
    map: PostProcessingEvidenceType.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseAny>;
  public postProcessingEvidenceTypeByMap(
    map: PostProcessingEvidenceType.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseAny>>;
  public postProcessingEvidenceTypeByMap(
    map: PostProcessingEvidenceType.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseAny>>;
  public postProcessingEvidenceTypeByMap(
    map: PostProcessingEvidenceType.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.postProcessingEvidenceType(
      map.ChainProcessingEvidenceType,
      observe,
      reportProgress
    );
  }


    /**
     * 
     * Inserts or updates a rocessing evidence type. When inserting fields _id, _rev and docType should not be present.
     * @param ChainProcessingEvidenceType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseAny>;
    public postProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseAny>>;
    public postProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseAny>>;
    public postProcessingEvidenceType(ChainProcessingEvidenceType: ChainProcessingEvidenceType, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ChainProcessingEvidenceType === null || ChainProcessingEvidenceType === undefined) {
            throw new Error('Required parameter ChainProcessingEvidenceType was null or undefined when calling postProcessingEvidenceType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseAny>(`${this.configuration.basePath}/chain-api/codebook/processing-evidence-type`,
            ChainProcessingEvidenceType,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'PostProcessingEvidenceType')));
        }
        return handle;
    }

}
