/*
 * Copyright(c) 2009 - 2019 Abelium d.o.o.
 * Kajuhova 90, 1000 Ljubljana, Slovenia
 * All rights reserved
 * Copyright(c) 1995 - 2018 T-Systems Multimedia Solutions GmbH
 * Riesaer Str. 5, 01129 Dresden
 * All rights reserved.
 *
 * INATrace Services API
 * Abelium INATrace Services API swagger documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the openapi-typescript-angular-generator.
 * https://github.com/alenabelium/openapi-typescript-angular-generator
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { ValidatorFn, Validators } from '@angular/forms';

import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import { catchError }                                        from 'rxjs/operators';

import { ApiBaseEntity } from '../model/apiBaseEntity';
import { ApiCompanyCustomer } from '../model/apiCompanyCustomer';
import { ApiDefaultResponse } from '../model/apiDefaultResponse';
import { ApiKnowledgeBlog } from '../model/apiKnowledgeBlog';
import { ApiPaginatedResponseApiCompanyCustomer } from '../model/apiPaginatedResponseApiCompanyCustomer';
import { ApiPaginatedResponseApiKnowledgeBlogBase } from '../model/apiPaginatedResponseApiKnowledgeBlogBase';
import { ApiPaginatedResponseApiProductLabelBatch } from '../model/apiPaginatedResponseApiProductLabelBatch';
import { ApiPaginatedResponseApiProductListResponse } from '../model/apiPaginatedResponseApiProductListResponse';
import { ApiProduct } from '../model/apiProduct';
import { ApiProductLabel } from '../model/apiProductLabel';
import { ApiProductLabelBatch } from '../model/apiProductLabelBatch';
import { ApiProductLabelContent } from '../model/apiProductLabelContent';
import { ApiProductLabelUpdateValues } from '../model/apiProductLabelUpdateValues';
import { ApiResponseApiBaseEntity } from '../model/apiResponseApiBaseEntity';
import { ApiResponseApiKnowledgeBlog } from '../model/apiResponseApiKnowledgeBlog';
import { ApiResponseApiProduct } from '../model/apiResponseApiProduct';
import { ApiResponseApiProductLabel } from '../model/apiResponseApiProductLabel';
import { ApiResponseApiProductLabelAnalytics } from '../model/apiResponseApiProductLabelAnalytics';
import { ApiResponseApiProductLabelBatch } from '../model/apiResponseApiProductLabelBatch';
import { ApiResponseApiProductLabelContent } from '../model/apiResponseApiProductLabelContent';
import { ApiResponseApiProductLabelValues } from '../model/apiResponseApiProductLabelValues';
import { ApiResponseListApiProductLabelBase } from '../model/apiResponseListApiProductLabelBase';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/**
 * Namespace for addCompanyCustomerUsingPOST.
 */
export namespace AddCompanyCustomerUsingPOST {
    /**
     * Parameter map for addCompanyCustomerUsingPOST.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      productId: number;
      /**
       * Company id
       */
      companyId: number;
      /**
       * request
       */
      ApiCompanyCustomer: ApiCompanyCustomer;
    }

    /**
     * Enumeration of all parameters for addCompanyCustomerUsingPOST.
     */
    export enum Parameters {
      /**
       * Product id
       */
      productId = 'productId',
      /**
       * Company id
       */
      companyId = 'companyId',
      /**
       * request
       */
      ApiCompanyCustomer = 'ApiCompanyCustomer'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of addCompanyCustomerUsingPOST
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof AddCompanyCustomerUsingPOST.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      companyId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for createProductLabelBatchUsingPOST.
 */
export namespace CreateProductLabelBatchUsingPOST {
    /**
     * Parameter map for createProductLabelBatchUsingPOST.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProductLabelBatch: ApiProductLabelBatch;
    }

    /**
     * Enumeration of all parameters for createProductLabelBatchUsingPOST.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProductLabelBatch = 'ApiProductLabelBatch'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createProductLabelBatchUsingPOST
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateProductLabelBatchUsingPOST.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for createProductLabelUsingPOST.
 */
export namespace CreateProductLabelUsingPOST {
    /**
     * Parameter map for createProductLabelUsingPOST.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProductLabel: ApiProductLabel;
    }

    /**
     * Enumeration of all parameters for createProductLabelUsingPOST.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProductLabel = 'ApiProductLabel'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createProductLabelUsingPOST
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateProductLabelUsingPOST.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for createProductUsingPOST.
 */
export namespace CreateProductUsingPOST {
    /**
     * Parameter map for createProductUsingPOST.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProduct: ApiProduct;
    }

    /**
     * Enumeration of all parameters for createProductUsingPOST.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProduct = 'ApiProduct'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of createProductUsingPOST
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof CreateProductUsingPOST.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for deleteCompanyCustomerUsingDELETE.
 */
export namespace DeleteCompanyCustomerUsingDELETE {
    /**
     * Parameter map for deleteCompanyCustomerUsingDELETE.
     */
    export interface PartialParamMap {
      /**
       * Customer id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteCompanyCustomerUsingDELETE.
     */
    export enum Parameters {
      /**
       * Customer id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteCompanyCustomerUsingDELETE
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteCompanyCustomerUsingDELETE.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductLabelBatchUsingDELETE.
 */
export namespace DeleteProductLabelBatchUsingDELETE {
    /**
     * Parameter map for deleteProductLabelBatchUsingDELETE.
     */
    export interface PartialParamMap {
      /**
       * Batch id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductLabelBatchUsingDELETE.
     */
    export enum Parameters {
      /**
       * Batch id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductLabelBatchUsingDELETE
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductLabelBatchUsingDELETE.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductLabelFeedbackUsingDELETE.
 */
export namespace DeleteProductLabelFeedbackUsingDELETE {
    /**
     * Parameter map for deleteProductLabelFeedbackUsingDELETE.
     */
    export interface PartialParamMap {
      /**
       * Feedback id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductLabelFeedbackUsingDELETE.
     */
    export enum Parameters {
      /**
       * Feedback id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductLabelFeedbackUsingDELETE
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductLabelFeedbackUsingDELETE.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductLabelUsingDELETE.
 */
export namespace DeleteProductLabelUsingDELETE {
    /**
     * Parameter map for deleteProductLabelUsingDELETE.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductLabelUsingDELETE.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductLabelUsingDELETE
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductLabelUsingDELETE.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for deleteProductUsingDELETE.
 */
export namespace DeleteProductUsingDELETE {
    /**
     * Parameter map for deleteProductUsingDELETE.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for deleteProductUsingDELETE.
     */
    export enum Parameters {
      /**
       * Product id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of deleteProductUsingDELETE
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof DeleteProductUsingDELETE.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for executeAction.
 */
export namespace ExecuteAction {
    /**
     * Parameter map for executeAction.
     */
    export interface PartialParamMap {
      /**
       * action
       */
      action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL';
      /**
       * request
       */
      ApiBaseEntity: ApiBaseEntity;
    }

    /**
     * Enumeration of all parameters for executeAction.
     */
    export enum Parameters {
      /**
       * action
       */
      action = 'action',
      /**
       * request
       */
      ApiBaseEntity = 'ApiBaseEntity'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of executeAction
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ExecuteAction.PartialParamMap]?: [string, ValidatorFn][]} = {
      action: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getCompanyCustomersListUsingGET.
 */
export namespace GetCompanyCustomersListUsingGET {
    /**
     * Parameter map for getCompanyCustomersListUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      productId: number;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
      /**
       * Name
       */
      query?: string;
      /**
       * Phone number
       */
      phone?: string;
    }

    /**
     * Enumeration of all parameters for getCompanyCustomersListUsingGET.
     */
    export enum Parameters {
      /**
       * Product id
       */
      productId = 'productId',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort',
      /**
       * Name
       */
      query = 'query',
      /**
       * Phone number
       */
      phone = 'phone'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getCompanyCustomersListUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetCompanyCustomersListUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      requestType: [
      ],
      limit: [
      ],
      offset: [
      ],
      sortBy: [
      ],
      sort: [
      ],
      query: [
      ],
      phone: [
      ],
    };
}

/**
 * Namespace for getProductKnowledgeBlog.
 */
export namespace GetProductKnowledgeBlog {
    /**
     * Parameter map for getProductKnowledgeBlog.
     */
    export interface PartialParamMap {
      /**
       * id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductKnowledgeBlog.
     */
    export enum Parameters {
      /**
       * id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductKnowledgeBlog
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductKnowledgeBlog.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductKnowledgeBlogUsingGET.
 */
export namespace GetProductKnowledgeBlogUsingGET {
    /**
     * Parameter map for getProductKnowledgeBlogUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      productId: number;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
      /**
       * knowledge blog type
       */
      type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE';
    }

    /**
     * Enumeration of all parameters for getProductKnowledgeBlogUsingGET.
     */
    export enum Parameters {
      /**
       * Product id
       */
      productId = 'productId',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort',
      /**
       * knowledge blog type
       */
      type = 'type'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductKnowledgeBlogUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductKnowledgeBlogUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
      requestType: [
      ],
      limit: [
      ],
      offset: [
      ],
      sortBy: [
      ],
      sort: [
      ],
      type: [
      ],
    };
}

/**
 * Namespace for getProductKnowledgeBlogUsingPOST.
 */
export namespace GetProductKnowledgeBlogUsingPOST {
    /**
     * Parameter map for getProductKnowledgeBlogUsingPOST.
     */
    export interface PartialParamMap {
      /**
       * type
       */
      productId: number;
      /**
       * request
       */
      ApiKnowledgeBlog: ApiKnowledgeBlog;
    }

    /**
     * Enumeration of all parameters for getProductKnowledgeBlogUsingPOST.
     */
    export enum Parameters {
      /**
       * type
       */
      productId = 'productId',
      /**
       * request
       */
      ApiKnowledgeBlog = 'ApiKnowledgeBlog'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductKnowledgeBlogUsingPOST
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductKnowledgeBlogUsingPOST.PartialParamMap]?: [string, ValidatorFn][]} = {
      productId: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductKnowledgeBlogUsingPUT.
 */
export namespace GetProductKnowledgeBlogUsingPUT {
    /**
     * Parameter map for getProductKnowledgeBlogUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiKnowledgeBlog: ApiKnowledgeBlog;
    }

    /**
     * Enumeration of all parameters for getProductKnowledgeBlogUsingPUT.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiKnowledgeBlog = 'ApiKnowledgeBlog'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductKnowledgeBlogUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductKnowledgeBlogUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for getProductLabelAnalyticsUsingGET.
 */
export namespace GetProductLabelAnalyticsUsingGET {
    /**
     * Parameter map for getProductLabelAnalyticsUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Label uid
       */
      uid: string;
    }

    /**
     * Enumeration of all parameters for getProductLabelAnalyticsUsingGET.
     */
    export enum Parameters {
      /**
       * Label uid
       */
      uid = 'uid'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelAnalyticsUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelAnalyticsUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      uid: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelBatchUsingGET.
 */
export namespace GetProductLabelBatchUsingGET {
    /**
     * Parameter map for getProductLabelBatchUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Batch id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelBatchUsingGET.
     */
    export enum Parameters {
      /**
       * Batch id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelBatchUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelBatchUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelBatchesUsingGET.
 */
export namespace GetProductLabelBatchesUsingGET {
    /**
     * Parameter map for getProductLabelBatchesUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
      /**
       * Batch number (start of it)
       */
      number?: string;
    }

    /**
     * Enumeration of all parameters for getProductLabelBatchesUsingGET.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id',
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort',
      /**
       * Batch number (start of it)
       */
      number = 'number'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelBatchesUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelBatchesUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
      requestType: [
      ],
      limit: [
      ],
      offset: [
      ],
      sortBy: [
      ],
      sort: [
      ],
      number: [
      ],
    };
}

/**
 * Namespace for getProductLabelContentUsingGET.
 */
export namespace GetProductLabelContentUsingGET {
    /**
     * Parameter map for getProductLabelContentUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelContentUsingGET.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelContentUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelContentUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelInstructionsUsingGET.
 */
export namespace GetProductLabelInstructionsUsingGET {
    /**
     * Parameter map for getProductLabelInstructionsUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Label id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelInstructionsUsingGET.
     */
    export enum Parameters {
      /**
       * Label id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelInstructionsUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelInstructionsUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelUsingGET.
 */
export namespace GetProductLabelUsingGET {
    /**
     * Parameter map for getProductLabelUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Record id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelUsingGET.
     */
    export enum Parameters {
      /**
       * Record id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelValuesUsingGET.
 */
export namespace GetProductLabelValuesUsingGET {
    /**
     * Parameter map for getProductLabelValuesUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Record id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelValuesUsingGET.
     */
    export enum Parameters {
      /**
       * Record id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelValuesUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelValuesUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductLabelsUsingGET.
 */
export namespace GetProductLabelsUsingGET {
    /**
     * Parameter map for getProductLabelsUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      id: number;
    }

    /**
     * Enumeration of all parameters for getProductLabelsUsingGET.
     */
    export enum Parameters {
      /**
       * Product id
       */
      id = 'id'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductLabelsUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductLabelsUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
    };
}

/**
 * Namespace for getProductUsingGET.
 */
export namespace GetProductUsingGET {
    /**
     * Parameter map for getProductUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Product id
       */
      id: number;
      /**
       * includeLabels
       */
      includeLabels?: boolean;
    }

    /**
     * Enumeration of all parameters for getProductUsingGET.
     */
    export enum Parameters {
      /**
       * Product id
       */
      id = 'id',
      /**
       * includeLabels
       */
      includeLabels = 'includeLabels'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of getProductUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof GetProductUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      id: [
              ['required', Validators.required],
      ],
      includeLabels: [
      ],
    };
}

/**
 * Namespace for listProductsAdminUsingGET.
 */
export namespace ListProductsAdminUsingGET {
    /**
     * Parameter map for listProductsAdminUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
      /**
       * Product name (start of name)
       */
      name?: string;
    }

    /**
     * Enumeration of all parameters for listProductsAdminUsingGET.
     */
    export enum Parameters {
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort',
      /**
       * Product name (start of name)
       */
      name = 'name'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listProductsAdminUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListProductsAdminUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      requestType: [
      ],
      limit: [
      ],
      offset: [
      ],
      sortBy: [
      ],
      sort: [
      ],
      name: [
      ],
    };
}

/**
 * Namespace for listProductsUsingGET.
 */
export namespace ListProductsUsingGET {
    /**
     * Parameter map for listProductsUsingGET.
     */
    export interface PartialParamMap {
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType?: 'COUNT' | 'FETCH';
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit?: number;
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset?: number;
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy?: string;
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort?: 'ASC' | 'DESC';
      /**
       * Product name (start of name)
       */
      name?: string;
    }

    /**
     * Enumeration of all parameters for listProductsUsingGET.
     */
    export enum Parameters {
      /**
       * Only count, only fetch, or return both values (if null)
       */
      requestType = 'requestType',
      /**
       * Number of records to return. Min: 1, default: 100
       */
      limit = 'limit',
      /**
       * Number of records to skip before returning. Default: 0, min: 0
       */
      offset = 'offset',
      /**
       * Column name to be sorted by, varies for each endpoint, default is id
       */
      sortBy = 'sortBy',
      /**
       * Direction of sorting (ASC or DESC). Default DESC.
       */
      sort = 'sort',
      /**
       * Product name (start of name)
       */
      name = 'name'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of listProductsUsingGET
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof ListProductsUsingGET.PartialParamMap]?: [string, ValidatorFn][]} = {
      requestType: [
      ],
      limit: [
      ],
      offset: [
      ],
      sortBy: [
      ],
      sort: [
      ],
      name: [
      ],
    };
}

/**
 * Namespace for updateCompanyCustomerUsingPUT.
 */
export namespace UpdateCompanyCustomerUsingPUT {
    /**
     * Parameter map for updateCompanyCustomerUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiCompanyCustomer: ApiCompanyCustomer;
    }

    /**
     * Enumeration of all parameters for updateCompanyCustomerUsingPUT.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiCompanyCustomer = 'ApiCompanyCustomer'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateCompanyCustomerUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateCompanyCustomerUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelBatchUsingPUT.
 */
export namespace UpdateProductLabelBatchUsingPUT {
    /**
     * Parameter map for updateProductLabelBatchUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProductLabelBatch: ApiProductLabelBatch;
    }

    /**
     * Enumeration of all parameters for updateProductLabelBatchUsingPUT.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProductLabelBatch = 'ApiProductLabelBatch'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelBatchUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelBatchUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelContentUsingPUT.
 */
export namespace UpdateProductLabelContentUsingPUT {
    /**
     * Parameter map for updateProductLabelContentUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProductLabelContent: ApiProductLabelContent;
    }

    /**
     * Enumeration of all parameters for updateProductLabelContentUsingPUT.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProductLabelContent = 'ApiProductLabelContent'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelContentUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelContentUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelUsingPUT.
 */
export namespace UpdateProductLabelUsingPUT {
    /**
     * Parameter map for updateProductLabelUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProductLabel: ApiProductLabel;
    }

    /**
     * Enumeration of all parameters for updateProductLabelUsingPUT.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProductLabel = 'ApiProductLabel'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductLabelValuesUsingPUT.
 */
export namespace UpdateProductLabelValuesUsingPUT {
    /**
     * Parameter map for updateProductLabelValuesUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * request
       */
      ApiProductLabelUpdateValues: ApiProductLabelUpdateValues;
    }

    /**
     * Enumeration of all parameters for updateProductLabelValuesUsingPUT.
     */
    export enum Parameters {
      /**
       * request
       */
      ApiProductLabelUpdateValues = 'ApiProductLabelUpdateValues'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductLabelValuesUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductLabelValuesUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}

/**
 * Namespace for updateProductUsingPUT.
 */
export namespace UpdateProductUsingPUT {
    /**
     * Parameter map for updateProductUsingPUT.
     */
    export interface PartialParamMap {
      /**
       * product
       */
      ApiProduct: ApiProduct;
    }

    /**
     * Enumeration of all parameters for updateProductUsingPUT.
     */
    export enum Parameters {
      /**
       * product
       */
      ApiProduct = 'ApiProduct'
    }

    /**
     * A map of tuples with error name and `ValidatorFn` for each parameter of updateProductUsingPUT
     * that does not have an own model.
     */
    export const ParamValidators: {[K in keyof UpdateProductUsingPUT.PartialParamMap]?: [string, ValidatorFn][]} = {
    };
}



@Injectable({
  providedIn: 'root'
})
export class ProductControllerService {

    protected basePath = 'http://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath != null ? configuration.basePath : (basePath != null ? basePath : this.basePath);
        } else {
            this.configuration.basePath = basePath != null ? basePath : this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }



  /**
   * Add company customer customer by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addCompanyCustomerUsingPOSTByMap(
    map: AddCompanyCustomerUsingPOST.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public addCompanyCustomerUsingPOSTByMap(
    map: AddCompanyCustomerUsingPOST.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public addCompanyCustomerUsingPOSTByMap(
    map: AddCompanyCustomerUsingPOST.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public addCompanyCustomerUsingPOSTByMap(
    map: AddCompanyCustomerUsingPOST.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.addCompanyCustomerUsingPOST(
      map.productId,
      map.companyId,
      map.ApiCompanyCustomer,
      observe,
      reportProgress
    );
  }


    /**
     * Add company customer customer
     * 
     * @param productId Product id
     * @param companyId Company id
     * @param ApiCompanyCustomer request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addCompanyCustomerUsingPOST(productId: number, companyId: number, ApiCompanyCustomer: ApiCompanyCustomer, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public addCompanyCustomerUsingPOST(productId: number, companyId: number, ApiCompanyCustomer: ApiCompanyCustomer, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public addCompanyCustomerUsingPOST(productId: number, companyId: number, ApiCompanyCustomer: ApiCompanyCustomer, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public addCompanyCustomerUsingPOST(productId: number, companyId: number, ApiCompanyCustomer: ApiCompanyCustomer, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling addCompanyCustomerUsingPOST.');
        }
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling addCompanyCustomerUsingPOST.');
        }
        if (ApiCompanyCustomer === null || ApiCompanyCustomer === undefined) {
            throw new Error('Required parameter ApiCompanyCustomer was null or undefined when calling addCompanyCustomerUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/companyCustomers/add/${encodeURIComponent(String(productId))}/${encodeURIComponent(String(companyId))}`,
            ApiCompanyCustomer,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'addCompanyCustomerUsingPOST')));
        }
        return handle;
    }


  /**
   * Create a new product label batch by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createProductLabelBatchUsingPOSTByMap(
    map: CreateProductLabelBatchUsingPOST.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createProductLabelBatchUsingPOSTByMap(
    map: CreateProductLabelBatchUsingPOST.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createProductLabelBatchUsingPOSTByMap(
    map: CreateProductLabelBatchUsingPOST.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createProductLabelBatchUsingPOSTByMap(
    map: CreateProductLabelBatchUsingPOST.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createProductLabelBatchUsingPOST(
      map.ApiProductLabelBatch,
      observe,
      reportProgress
    );
  }


    /**
     * Create a new product label batch
     * 
     * @param ApiProductLabelBatch request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductLabelBatchUsingPOST(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createProductLabelBatchUsingPOST(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createProductLabelBatchUsingPOST(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createProductLabelBatchUsingPOST(ApiProductLabelBatch: ApiProductLabelBatch, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelBatch === null || ApiProductLabelBatch === undefined) {
            throw new Error('Required parameter ApiProductLabelBatch was null or undefined when calling createProductLabelBatchUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/label_batch/create`,
            ApiProductLabelBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createProductLabelBatchUsingPOST')));
        }
        return handle;
    }


  /**
   * Create a new product label by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createProductLabelUsingPOSTByMap(
    map: CreateProductLabelUsingPOST.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createProductLabelUsingPOSTByMap(
    map: CreateProductLabelUsingPOST.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createProductLabelUsingPOSTByMap(
    map: CreateProductLabelUsingPOST.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createProductLabelUsingPOSTByMap(
    map: CreateProductLabelUsingPOST.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createProductLabelUsingPOST(
      map.ApiProductLabel,
      observe,
      reportProgress
    );
  }


    /**
     * Create a new product label
     * 
     * @param ApiProductLabel request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductLabelUsingPOST(ApiProductLabel: ApiProductLabel, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createProductLabelUsingPOST(ApiProductLabel: ApiProductLabel, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createProductLabelUsingPOST(ApiProductLabel: ApiProductLabel, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createProductLabelUsingPOST(ApiProductLabel: ApiProductLabel, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabel === null || ApiProductLabel === undefined) {
            throw new Error('Required parameter ApiProductLabel was null or undefined when calling createProductLabelUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/label/create`,
            ApiProductLabel,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createProductLabelUsingPOST')));
        }
        return handle;
    }


  /**
   * Create a new product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createProductUsingPOSTByMap(
    map: CreateProductUsingPOST.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiBaseEntity>;
  public createProductUsingPOSTByMap(
    map: CreateProductUsingPOST.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
  public createProductUsingPOSTByMap(
    map: CreateProductUsingPOST.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
  public createProductUsingPOSTByMap(
    map: CreateProductUsingPOST.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.createProductUsingPOST(
      map.ApiProduct,
      observe,
      reportProgress
    );
  }


    /**
     * Create a new product
     * 
     * @param ApiProduct request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProductUsingPOST(ApiProduct: ApiProduct, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiBaseEntity>;
    public createProductUsingPOST(ApiProduct: ApiProduct, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiBaseEntity>>;
    public createProductUsingPOST(ApiProduct: ApiProduct, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiBaseEntity>>;
    public createProductUsingPOST(ApiProduct: ApiProduct, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProduct === null || ApiProduct === undefined) {
            throw new Error('Required parameter ApiProduct was null or undefined when calling createProductUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiResponseApiBaseEntity>(`${this.configuration.basePath}/api/product/create`,
            ApiProduct,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'createProductUsingPOST')));
        }
        return handle;
    }


  /**
   * Deletes a company customer by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteCompanyCustomerUsingDELETEByMap(
    map: DeleteCompanyCustomerUsingDELETE.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteCompanyCustomerUsingDELETEByMap(
    map: DeleteCompanyCustomerUsingDELETE.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteCompanyCustomerUsingDELETEByMap(
    map: DeleteCompanyCustomerUsingDELETE.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteCompanyCustomerUsingDELETEByMap(
    map: DeleteCompanyCustomerUsingDELETE.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteCompanyCustomerUsingDELETE(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a company customer
     * 
     * @param id Customer id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteCompanyCustomerUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteCompanyCustomerUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteCompanyCustomerUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteCompanyCustomerUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCompanyCustomerUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/companyCustomers/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteCompanyCustomerUsingDELETE')));
        }
        return handle;
    }


  /**
   * Deletes a product label batch by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductLabelBatchUsingDELETEByMap(
    map: DeleteProductLabelBatchUsingDELETE.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductLabelBatchUsingDELETEByMap(
    map: DeleteProductLabelBatchUsingDELETE.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductLabelBatchUsingDELETEByMap(
    map: DeleteProductLabelBatchUsingDELETE.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductLabelBatchUsingDELETEByMap(
    map: DeleteProductLabelBatchUsingDELETE.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductLabelBatchUsingDELETE(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product label batch
     * 
     * @param id Batch id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductLabelBatchUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductLabelBatchUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductLabelBatchUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductLabelBatchUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductLabelBatchUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label_batch/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductLabelBatchUsingDELETE')));
        }
        return handle;
    }


  /**
   * Deletes a product label feedback by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductLabelFeedbackUsingDELETEByMap(
    map: DeleteProductLabelFeedbackUsingDELETE.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductLabelFeedbackUsingDELETEByMap(
    map: DeleteProductLabelFeedbackUsingDELETE.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductLabelFeedbackUsingDELETEByMap(
    map: DeleteProductLabelFeedbackUsingDELETE.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductLabelFeedbackUsingDELETEByMap(
    map: DeleteProductLabelFeedbackUsingDELETE.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductLabelFeedbackUsingDELETE(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product label feedback
     * 
     * @param id Feedback id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductLabelFeedbackUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductLabelFeedbackUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductLabelFeedbackUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductLabelFeedbackUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductLabelFeedbackUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/feedback/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductLabelFeedbackUsingDELETE')));
        }
        return handle;
    }


  /**
   * Deletes a product label by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductLabelUsingDELETEByMap(
    map: DeleteProductLabelUsingDELETE.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductLabelUsingDELETEByMap(
    map: DeleteProductLabelUsingDELETE.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductLabelUsingDELETEByMap(
    map: DeleteProductLabelUsingDELETE.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductLabelUsingDELETEByMap(
    map: DeleteProductLabelUsingDELETE.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductLabelUsingDELETE(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product label
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductLabelUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductLabelUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductLabelUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductLabelUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductLabelUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductLabelUsingDELETE')));
        }
        return handle;
    }


  /**
   * Deletes a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteProductUsingDELETEByMap(
    map: DeleteProductUsingDELETE.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public deleteProductUsingDELETEByMap(
    map: DeleteProductUsingDELETE.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public deleteProductUsingDELETEByMap(
    map: DeleteProductUsingDELETE.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public deleteProductUsingDELETEByMap(
    map: DeleteProductUsingDELETE.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.deleteProductUsingDELETE(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Deletes a product
     * 
     * @param id Product id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProductUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public deleteProductUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public deleteProductUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public deleteProductUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.delete<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'deleteProductUsingDELETE')));
        }
        return handle;
    }


  /**
   * Execute action by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public executeActionByMap(
    map: ExecuteAction.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public executeActionByMap(
    map: ExecuteAction.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public executeActionByMap(
    map: ExecuteAction.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public executeActionByMap(
    map: ExecuteAction.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.executeAction(
      map.action,
      map.ApiBaseEntity,
      observe,
      reportProgress
    );
  }


    /**
     * Execute action
     * 
     * @param action action
     * @param ApiBaseEntity request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public executeAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public executeAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public executeAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public executeAction(action: 'PUBLISH_LABEL' | 'UNPUBLISH_LABEL', ApiBaseEntity: ApiBaseEntity, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling executeAction.');
        }
        if (ApiBaseEntity === null || ApiBaseEntity === undefined) {
            throw new Error('Required parameter ApiBaseEntity was null or undefined when calling executeAction.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/execute/${encodeURIComponent(String(action))}`,
            ApiBaseEntity,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'executeAction')));
        }
        return handle;
    }


  /**
   * List company customers for a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCompanyCustomersListUsingGETByMap(
    map: GetCompanyCustomersListUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiCompanyCustomer>;
  public getCompanyCustomersListUsingGETByMap(
    map: GetCompanyCustomersListUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiCompanyCustomer>>;
  public getCompanyCustomersListUsingGETByMap(
    map: GetCompanyCustomersListUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiCompanyCustomer>>;
  public getCompanyCustomersListUsingGETByMap(
    map: GetCompanyCustomersListUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getCompanyCustomersListUsingGET(
      map.productId,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      map.query,
      map.phone,
      observe,
      reportProgress
    );
  }


    /**
     * List company customers for a product
     * 
     * @param productId Product id
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param query Name
     * @param phone Phone number
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompanyCustomersListUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', query?: string, phone?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiCompanyCustomer>;
    public getCompanyCustomersListUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', query?: string, phone?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiCompanyCustomer>>;
    public getCompanyCustomersListUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', query?: string, phone?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiCompanyCustomer>>;
    public getCompanyCustomersListUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', query?: string, phone?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getCompanyCustomersListUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (query !== undefined && query !== null) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (phone !== undefined && phone !== null) {
            queryParameters = queryParameters.set('phone', <any>phone);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiCompanyCustomer>(`${this.configuration.basePath}/api/product/companyCustomers/list/${encodeURIComponent(String(productId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getCompanyCustomersListUsingGET')));
        }
        return handle;
    }


  /**
   * Get knowledge blog by id by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiKnowledgeBlog>;
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiKnowledgeBlog>>;
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiKnowledgeBlog>>;
  public getProductKnowledgeBlogByMap(
    map: GetProductKnowledgeBlog.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductKnowledgeBlog(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get knowledge blog by id
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductKnowledgeBlog(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiKnowledgeBlog>;
    public getProductKnowledgeBlog(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiKnowledgeBlog>>;
    public getProductKnowledgeBlog(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiKnowledgeBlog>>;
    public getProductKnowledgeBlog(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductKnowledgeBlog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiKnowledgeBlog>(`${this.configuration.basePath}/api/product/knowledgeBlog/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductKnowledgeBlog')));
        }
        return handle;
    }


  /**
   * Get knowledge blogs for a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductKnowledgeBlogUsingGETByMap(
    map: GetProductKnowledgeBlogUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiKnowledgeBlogBase>;
  public getProductKnowledgeBlogUsingGETByMap(
    map: GetProductKnowledgeBlogUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiKnowledgeBlogBase>>;
  public getProductKnowledgeBlogUsingGETByMap(
    map: GetProductKnowledgeBlogUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiKnowledgeBlogBase>>;
  public getProductKnowledgeBlogUsingGETByMap(
    map: GetProductKnowledgeBlogUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductKnowledgeBlogUsingGET(
      map.productId,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      map.type,
      observe,
      reportProgress
    );
  }


    /**
     * Get knowledge blogs for a product
     * 
     * @param productId Product id
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param type knowledge blog type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductKnowledgeBlogUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiKnowledgeBlogBase>;
    public getProductKnowledgeBlogUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiKnowledgeBlogBase>>;
    public getProductKnowledgeBlogUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiKnowledgeBlogBase>>;
    public getProductKnowledgeBlogUsingGET(productId: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', type?: 'FAIRNESS' | 'QUALITY' | 'PROVENANCE', observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductKnowledgeBlogUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (type !== undefined && type !== null) {
            queryParameters = queryParameters.set('type', <any>type);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiKnowledgeBlogBase>(`${this.configuration.basePath}/api/product/knowledgeBlog/list/${encodeURIComponent(String(productId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductKnowledgeBlogUsingGET')));
        }
        return handle;
    }


  /**
   * Add knowledge blog to a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductKnowledgeBlogUsingPOSTByMap(
    map: GetProductKnowledgeBlogUsingPOST.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public getProductKnowledgeBlogUsingPOSTByMap(
    map: GetProductKnowledgeBlogUsingPOST.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public getProductKnowledgeBlogUsingPOSTByMap(
    map: GetProductKnowledgeBlogUsingPOST.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public getProductKnowledgeBlogUsingPOSTByMap(
    map: GetProductKnowledgeBlogUsingPOST.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductKnowledgeBlogUsingPOST(
      map.productId,
      map.ApiKnowledgeBlog,
      observe,
      reportProgress
    );
  }


    /**
     * Add knowledge blog to a product
     * 
     * @param productId type
     * @param ApiKnowledgeBlog request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductKnowledgeBlogUsingPOST(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public getProductKnowledgeBlogUsingPOST(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public getProductKnowledgeBlogUsingPOST(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public getProductKnowledgeBlogUsingPOST(productId: number, ApiKnowledgeBlog: ApiKnowledgeBlog, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getProductKnowledgeBlogUsingPOST.');
        }
        if (ApiKnowledgeBlog === null || ApiKnowledgeBlog === undefined) {
            throw new Error('Required parameter ApiKnowledgeBlog was null or undefined when calling getProductKnowledgeBlogUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.post<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/knowledgeBlog/${encodeURIComponent(String(productId))}`,
            ApiKnowledgeBlog,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductKnowledgeBlogUsingPOST')));
        }
        return handle;
    }


  /**
   * Update knowledge blog by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductKnowledgeBlogUsingPUTByMap(
    map: GetProductKnowledgeBlogUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public getProductKnowledgeBlogUsingPUTByMap(
    map: GetProductKnowledgeBlogUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public getProductKnowledgeBlogUsingPUTByMap(
    map: GetProductKnowledgeBlogUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public getProductKnowledgeBlogUsingPUTByMap(
    map: GetProductKnowledgeBlogUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductKnowledgeBlogUsingPUT(
      map.ApiKnowledgeBlog,
      observe,
      reportProgress
    );
  }


    /**
     * Update knowledge blog
     * 
     * @param ApiKnowledgeBlog request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductKnowledgeBlogUsingPUT(ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public getProductKnowledgeBlogUsingPUT(ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public getProductKnowledgeBlogUsingPUT(ApiKnowledgeBlog: ApiKnowledgeBlog, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public getProductKnowledgeBlogUsingPUT(ApiKnowledgeBlog: ApiKnowledgeBlog, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiKnowledgeBlog === null || ApiKnowledgeBlog === undefined) {
            throw new Error('Required parameter ApiKnowledgeBlog was null or undefined when calling getProductKnowledgeBlogUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/knowledgeBlog`,
            ApiKnowledgeBlog,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductKnowledgeBlogUsingPUT')));
        }
        return handle;
    }


  /**
   * Get label data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelAnalyticsUsingGETByMap(
    map: GetProductLabelAnalyticsUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelAnalytics>;
  public getProductLabelAnalyticsUsingGETByMap(
    map: GetProductLabelAnalyticsUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelAnalytics>>;
  public getProductLabelAnalyticsUsingGETByMap(
    map: GetProductLabelAnalyticsUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelAnalytics>>;
  public getProductLabelAnalyticsUsingGETByMap(
    map: GetProductLabelAnalyticsUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelAnalyticsUsingGET(
      map.uid,
      observe,
      reportProgress
    );
  }


    /**
     * Get label data
     * 
     * @param uid Label uid
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelAnalyticsUsingGET(uid: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelAnalytics>;
    public getProductLabelAnalyticsUsingGET(uid: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelAnalytics>>;
    public getProductLabelAnalyticsUsingGET(uid: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelAnalytics>>;
    public getProductLabelAnalyticsUsingGET(uid: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (uid === null || uid === undefined) {
            throw new Error('Required parameter uid was null or undefined when calling getProductLabelAnalyticsUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelAnalytics>(`${this.configuration.basePath}/api/product/label/analytics/${encodeURIComponent(String(uid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelAnalyticsUsingGET')));
        }
        return handle;
    }


  /**
   * Get label batch data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelBatchUsingGETByMap(
    map: GetProductLabelBatchUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelBatch>;
  public getProductLabelBatchUsingGETByMap(
    map: GetProductLabelBatchUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelBatch>>;
  public getProductLabelBatchUsingGETByMap(
    map: GetProductLabelBatchUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelBatch>>;
  public getProductLabelBatchUsingGETByMap(
    map: GetProductLabelBatchUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelBatchUsingGET(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label batch data
     * 
     * @param id Batch id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelBatchUsingGET(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelBatch>;
    public getProductLabelBatchUsingGET(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelBatch>>;
    public getProductLabelBatchUsingGET(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelBatch>>;
    public getProductLabelBatchUsingGET(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelBatchUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelBatch>(`${this.configuration.basePath}/api/product/label_batch/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelBatchUsingGET')));
        }
        return handle;
    }


  /**
   * Get label batches for specified label. Sorting: number or productionDate, expiryDate by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelBatchesUsingGETByMap(
    map: GetProductLabelBatchesUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiProductLabelBatch>;
  public getProductLabelBatchesUsingGETByMap(
    map: GetProductLabelBatchesUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiProductLabelBatch>>;
  public getProductLabelBatchesUsingGETByMap(
    map: GetProductLabelBatchesUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiProductLabelBatch>>;
  public getProductLabelBatchesUsingGETByMap(
    map: GetProductLabelBatchesUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelBatchesUsingGET(
      map.id,
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      map.number,
      observe,
      reportProgress
    );
  }


    /**
     * Get label batches for specified label. Sorting: number or productionDate, expiryDate
     * 
     * @param id Label id
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param number Batch number (start of it)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelBatchesUsingGET(id: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', number?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiProductLabelBatch>;
    public getProductLabelBatchesUsingGET(id: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', number?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiProductLabelBatch>>;
    public getProductLabelBatchesUsingGET(id: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', number?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiProductLabelBatch>>;
    public getProductLabelBatchesUsingGET(id: number, requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', number?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelBatchesUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (number !== undefined && number !== null) {
            queryParameters = queryParameters.set('number', <any>number);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiProductLabelBatch>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}/batches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelBatchesUsingGET')));
        }
        return handle;
    }


  /**
   * Get label content by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelContentUsingGETByMap(
    map: GetProductLabelContentUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelContent>;
  public getProductLabelContentUsingGETByMap(
    map: GetProductLabelContentUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelContent>>;
  public getProductLabelContentUsingGETByMap(
    map: GetProductLabelContentUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelContent>>;
  public getProductLabelContentUsingGETByMap(
    map: GetProductLabelContentUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelContentUsingGET(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label content
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelContentUsingGET(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelContent>;
    public getProductLabelContentUsingGET(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelContent>>;
    public getProductLabelContentUsingGET(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelContent>>;
    public getProductLabelContentUsingGET(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelContentUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelContent>(`${this.configuration.basePath}/api/product/label/content/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelContentUsingGET')));
        }
        return handle;
    }


  /**
   * getProductLabelInstructions by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelInstructionsUsingGETByMap(
    map: GetProductLabelInstructionsUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<Blob>;
  public getProductLabelInstructionsUsingGETByMap(
    map: GetProductLabelInstructionsUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<Blob>>;
  public getProductLabelInstructionsUsingGETByMap(
    map: GetProductLabelInstructionsUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<Blob>>;
  public getProductLabelInstructionsUsingGETByMap(
    map: GetProductLabelInstructionsUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelInstructionsUsingGET(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * getProductLabelInstructions
     * 
     * @param id Label id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelInstructionsUsingGET(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<Blob>;
    public getProductLabelInstructionsUsingGET(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<Blob>>;
    public getProductLabelInstructionsUsingGET(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<Blob>>;
    public getProductLabelInstructionsUsingGET(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelInstructionsUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}/instructions`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelInstructionsUsingGET')));
        }
        return handle;
    }


  /**
   * Get label data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelUsingGETByMap(
    map: GetProductLabelUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabel>;
  public getProductLabelUsingGETByMap(
    map: GetProductLabelUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabel>>;
  public getProductLabelUsingGETByMap(
    map: GetProductLabelUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabel>>;
  public getProductLabelUsingGETByMap(
    map: GetProductLabelUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelUsingGET(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label data
     * 
     * @param id Record id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelUsingGET(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabel>;
    public getProductLabelUsingGET(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabel>>;
    public getProductLabelUsingGET(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabel>>;
    public getProductLabelUsingGET(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabel>(`${this.configuration.basePath}/api/product/label/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelUsingGET')));
        }
        return handle;
    }


  /**
   * Get label with field values by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelValuesUsingGETByMap(
    map: GetProductLabelValuesUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProductLabelValues>;
  public getProductLabelValuesUsingGETByMap(
    map: GetProductLabelValuesUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProductLabelValues>>;
  public getProductLabelValuesUsingGETByMap(
    map: GetProductLabelValuesUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProductLabelValues>>;
  public getProductLabelValuesUsingGETByMap(
    map: GetProductLabelValuesUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelValuesUsingGET(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get label with field values
     * 
     * @param id Record id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelValuesUsingGET(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProductLabelValues>;
    public getProductLabelValuesUsingGET(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProductLabelValues>>;
    public getProductLabelValuesUsingGET(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProductLabelValues>>;
    public getProductLabelValuesUsingGET(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelValuesUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProductLabelValues>(`${this.configuration.basePath}/api/product/label/values/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelValuesUsingGET')));
        }
        return handle;
    }


  /**
   * Get labels for product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductLabelsUsingGETByMap(
    map: GetProductLabelsUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseListApiProductLabelBase>;
  public getProductLabelsUsingGETByMap(
    map: GetProductLabelsUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseListApiProductLabelBase>>;
  public getProductLabelsUsingGETByMap(
    map: GetProductLabelsUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseListApiProductLabelBase>>;
  public getProductLabelsUsingGETByMap(
    map: GetProductLabelsUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductLabelsUsingGET(
      map.id,
      observe,
      reportProgress
    );
  }


    /**
     * Get labels for product
     * 
     * @param id Product id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductLabelsUsingGET(id: number, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseListApiProductLabelBase>;
    public getProductLabelsUsingGET(id: number, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseListApiProductLabelBase>>;
    public getProductLabelsUsingGET(id: number, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseListApiProductLabelBase>>;
    public getProductLabelsUsingGET(id: number, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductLabelsUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseListApiProductLabelBase>(`${this.configuration.basePath}/api/product/labels/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductLabelsUsingGET')));
        }
        return handle;
    }


  /**
   * Get all info about a product by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProductUsingGETByMap(
    map: GetProductUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiResponseApiProduct>;
  public getProductUsingGETByMap(
    map: GetProductUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiResponseApiProduct>>;
  public getProductUsingGETByMap(
    map: GetProductUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiResponseApiProduct>>;
  public getProductUsingGETByMap(
    map: GetProductUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.getProductUsingGET(
      map.id,
      map.includeLabels,
      observe,
      reportProgress
    );
  }


    /**
     * Get all info about a product
     * 
     * @param id Product id
     * @param includeLabels includeLabels
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProductUsingGET(id: number, includeLabels?: boolean, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiResponseApiProduct>;
    public getProductUsingGET(id: number, includeLabels?: boolean, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiResponseApiProduct>>;
    public getProductUsingGET(id: number, includeLabels?: boolean, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiResponseApiProduct>>;
    public getProductUsingGET(id: number, includeLabels?: boolean, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeLabels !== undefined && includeLabels !== null) {
            queryParameters = queryParameters.set('includeLabels', <any>includeLabels);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiResponseApiProduct>(`${this.configuration.basePath}/api/product/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'getProductUsingGET')));
        }
        return handle;
    }


  /**
   * Lists all products. Must be admin. Sorting: name or default by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listProductsAdminUsingGETByMap(
    map: ListProductsAdminUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiProductListResponse>;
  public listProductsAdminUsingGETByMap(
    map: ListProductsAdminUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsAdminUsingGETByMap(
    map: ListProductsAdminUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsAdminUsingGETByMap(
    map: ListProductsAdminUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listProductsAdminUsingGET(
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      map.name,
      observe,
      reportProgress
    );
  }


    /**
     * Lists all products. Must be admin. Sorting: name or default
     * 
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param name Product name (start of name)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductsAdminUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiProductListResponse>;
    public listProductsAdminUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
    public listProductsAdminUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
    public listProductsAdminUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiProductListResponse>(`${this.configuration.basePath}/api/product/admin/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'listProductsAdminUsingGET')));
        }
        return handle;
    }


  /**
   * Lists all products. Sorting: name or default by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public listProductsUsingGETByMap(
    map: ListProductsUsingGET.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiPaginatedResponseApiProductListResponse>;
  public listProductsUsingGETByMap(
    map: ListProductsUsingGET.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsUsingGETByMap(
    map: ListProductsUsingGET.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
  public listProductsUsingGETByMap(
    map: ListProductsUsingGET.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.listProductsUsingGET(
      map.requestType,
      map.limit,
      map.offset,
      map.sortBy,
      map.sort,
      map.name,
      observe,
      reportProgress
    );
  }


    /**
     * Lists all products. Sorting: name or default
     * 
     * @param requestType Only count, only fetch, or return both values (if null)
     * @param limit Number of records to return. Min: 1, default: 100
     * @param offset Number of records to skip before returning. Default: 0, min: 0
     * @param sortBy Column name to be sorted by, varies for each endpoint, default is id
     * @param sort Direction of sorting (ASC or DESC). Default DESC.
     * @param name Product name (start of name)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listProductsUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiPaginatedResponseApiProductListResponse>;
    public listProductsUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiPaginatedResponseApiProductListResponse>>;
    public listProductsUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiPaginatedResponseApiProductListResponse>>;
    public listProductsUsingGET(requestType?: 'COUNT' | 'FETCH', limit?: number, offset?: number, sortBy?: string, sort?: 'ASC' | 'DESC', name?: string, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (requestType !== undefined && requestType !== null) {
            queryParameters = queryParameters.set('requestType', <any>requestType);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sortBy', <any>sortBy);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.get<ApiPaginatedResponseApiProductListResponse>(`${this.configuration.basePath}/api/product/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'listProductsUsingGET')));
        }
        return handle;
    }


  /**
   * Update company customer by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateCompanyCustomerUsingPUTByMap(
    map: UpdateCompanyCustomerUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateCompanyCustomerUsingPUTByMap(
    map: UpdateCompanyCustomerUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateCompanyCustomerUsingPUTByMap(
    map: UpdateCompanyCustomerUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateCompanyCustomerUsingPUTByMap(
    map: UpdateCompanyCustomerUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateCompanyCustomerUsingPUT(
      map.ApiCompanyCustomer,
      observe,
      reportProgress
    );
  }


    /**
     * Update company customer
     * 
     * @param ApiCompanyCustomer request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateCompanyCustomerUsingPUT(ApiCompanyCustomer: ApiCompanyCustomer, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateCompanyCustomerUsingPUT(ApiCompanyCustomer: ApiCompanyCustomer, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateCompanyCustomerUsingPUT(ApiCompanyCustomer: ApiCompanyCustomer, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateCompanyCustomerUsingPUT(ApiCompanyCustomer: ApiCompanyCustomer, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiCompanyCustomer === null || ApiCompanyCustomer === undefined) {
            throw new Error('Required parameter ApiCompanyCustomer was null or undefined when calling updateCompanyCustomerUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/companyCustomers`,
            ApiCompanyCustomer,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateCompanyCustomerUsingPUT')));
        }
        return handle;
    }


  /**
   * Update label batch data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelBatchUsingPUTByMap(
    map: UpdateProductLabelBatchUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelBatchUsingPUTByMap(
    map: UpdateProductLabelBatchUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelBatchUsingPUTByMap(
    map: UpdateProductLabelBatchUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelBatchUsingPUTByMap(
    map: UpdateProductLabelBatchUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelBatchUsingPUT(
      map.ApiProductLabelBatch,
      observe,
      reportProgress
    );
  }


    /**
     * Update label batch data
     * 
     * @param ApiProductLabelBatch request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelBatchUsingPUT(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelBatchUsingPUT(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelBatchUsingPUT(ApiProductLabelBatch: ApiProductLabelBatch, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelBatchUsingPUT(ApiProductLabelBatch: ApiProductLabelBatch, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelBatch === null || ApiProductLabelBatch === undefined) {
            throw new Error('Required parameter ApiProductLabelBatch was null or undefined when calling updateProductLabelBatchUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label_batch`,
            ApiProductLabelBatch,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelBatchUsingPUT')));
        }
        return handle;
    }


  /**
   * Update label content by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelContentUsingPUTByMap(
    map: UpdateProductLabelContentUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelContentUsingPUTByMap(
    map: UpdateProductLabelContentUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelContentUsingPUTByMap(
    map: UpdateProductLabelContentUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelContentUsingPUTByMap(
    map: UpdateProductLabelContentUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelContentUsingPUT(
      map.ApiProductLabelContent,
      observe,
      reportProgress
    );
  }


    /**
     * Update label content
     * 
     * @param ApiProductLabelContent request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelContentUsingPUT(ApiProductLabelContent: ApiProductLabelContent, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelContentUsingPUT(ApiProductLabelContent: ApiProductLabelContent, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelContentUsingPUT(ApiProductLabelContent: ApiProductLabelContent, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelContentUsingPUT(ApiProductLabelContent: ApiProductLabelContent, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelContent === null || ApiProductLabelContent === undefined) {
            throw new Error('Required parameter ApiProductLabelContent was null or undefined when calling updateProductLabelContentUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/content`,
            ApiProductLabelContent,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelContentUsingPUT')));
        }
        return handle;
    }


  /**
   * Update label data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelUsingPUTByMap(
    map: UpdateProductLabelUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelUsingPUTByMap(
    map: UpdateProductLabelUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelUsingPUTByMap(
    map: UpdateProductLabelUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelUsingPUTByMap(
    map: UpdateProductLabelUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelUsingPUT(
      map.ApiProductLabel,
      observe,
      reportProgress
    );
  }


    /**
     * Update label data
     * 
     * @param ApiProductLabel request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelUsingPUT(ApiProductLabel: ApiProductLabel, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelUsingPUT(ApiProductLabel: ApiProductLabel, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelUsingPUT(ApiProductLabel: ApiProductLabel, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelUsingPUT(ApiProductLabel: ApiProductLabel, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabel === null || ApiProductLabel === undefined) {
            throw new Error('Required parameter ApiProductLabel was null or undefined when calling updateProductLabelUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label`,
            ApiProductLabel,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelUsingPUT')));
        }
        return handle;
    }


  /**
   * Update field values by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductLabelValuesUsingPUTByMap(
    map: UpdateProductLabelValuesUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductLabelValuesUsingPUTByMap(
    map: UpdateProductLabelValuesUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductLabelValuesUsingPUTByMap(
    map: UpdateProductLabelValuesUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductLabelValuesUsingPUTByMap(
    map: UpdateProductLabelValuesUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductLabelValuesUsingPUT(
      map.ApiProductLabelUpdateValues,
      observe,
      reportProgress
    );
  }


    /**
     * Update field values
     * 
     * @param ApiProductLabelUpdateValues request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductLabelValuesUsingPUT(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductLabelValuesUsingPUT(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductLabelValuesUsingPUT(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductLabelValuesUsingPUT(ApiProductLabelUpdateValues: ApiProductLabelUpdateValues, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProductLabelUpdateValues === null || ApiProductLabelUpdateValues === undefined) {
            throw new Error('Required parameter ApiProductLabelUpdateValues was null or undefined when calling updateProductLabelValuesUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/label/values`,
            ApiProductLabelUpdateValues,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductLabelValuesUsingPUT')));
        }
        return handle;
    }


  /**
   * Update product data by map.
   * 
   * @param map parameters map to set partial amount of parameters easily
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateProductUsingPUTByMap(
    map: UpdateProductUsingPUT.PartialParamMap,
    observe?: 'body',
    reportProgress?: boolean): Observable<ApiDefaultResponse>;
  public updateProductUsingPUTByMap(
    map: UpdateProductUsingPUT.PartialParamMap,
    observe?: 'response',
    reportProgress?: boolean): Observable<HttpResponse<ApiDefaultResponse>>;
  public updateProductUsingPUTByMap(
    map: UpdateProductUsingPUT.PartialParamMap,
    observe?: 'events',
    reportProgress?: boolean): Observable<HttpEvent<ApiDefaultResponse>>;
  public updateProductUsingPUTByMap(
    map: UpdateProductUsingPUT.PartialParamMap,
    observe: any = 'body',
    reportProgress: boolean = false): Observable<any> {
    return this.updateProductUsingPUT(
      map.ApiProduct,
      observe,
      reportProgress
    );
  }


    /**
     * Update product data
     * 
     * @param ApiProduct product
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProductUsingPUT(ApiProduct: ApiProduct, observe?: 'body', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<ApiDefaultResponse>;
    public updateProductUsingPUT(ApiProduct: ApiProduct, observe?: 'response', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpResponse<ApiDefaultResponse>>;
    public updateProductUsingPUT(ApiProduct: ApiProduct, observe?: 'events', reportProgress?: boolean, additionalHeaders?: Array<Array<string>>): Observable<HttpEvent<ApiDefaultResponse>>;
    public updateProductUsingPUT(ApiProduct: ApiProduct, observe: any = 'body', reportProgress: boolean = false, additionalHeaders?: Array<Array<string>>): Observable<any> {
        if (ApiProduct === null || ApiProduct === undefined) {
            throw new Error('Required parameter ApiProduct was null or undefined when calling updateProductUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

            if (additionalHeaders) {
                for(let pair of additionalHeaders) {
                    headers = headers.set(pair[0], pair[1]);
                }
            }

        const handle = this.httpClient.put<ApiDefaultResponse>(`${this.configuration.basePath}/api/product/`,
            ApiProduct,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
        if(typeof this.configuration.errorHandler === 'function') {
          return handle.pipe(catchError(err => this.configuration.errorHandler(err, 'updateProductUsingPUT')));
        }
        return handle;
    }

}
